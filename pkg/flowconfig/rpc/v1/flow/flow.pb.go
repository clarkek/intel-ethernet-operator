// Code generated by protoc-gen-go. DO NOT EDIT.
// source: flow.proto

/*
Package flow is a generated protocol buffer package.

It is generated from these files:
	flow.proto

It has these top-level messages:
	RteFlowAttr
	GreKeyDefaultMask
	RteFlowItemAny
	RteFlowItemVf
	RteFlowItemPhyPort
	RteFlowItemPortId
	RteFlowItemRaw
	RteEtherAddr
	RteFlowItemEth
	RteFlowItemVlan
	RteIpv4Hdr
	RteFlowItemIpv4
	RteIpv6Hdr
	RteFlowItemIpv6
	RteIcmpHdr
	RteFlowItemIcmp
	RteUdpHdr
	RteFlowItemUdp
	RteTcpHdr
	RteFlowItemTcp
	RteSctpHdr
	RteFlowItemSctp
	RteFlowItemVxlan
	RteFlowItemETag
	RteFlowItemNvgre
	RteFlowItemMpls
	RteFlowItemGre
	RteFlowItemFuzzy
	RteFlowItemGtp
	RteEspHdr
	RteFlowItemEsp
	RteFlowItemGeneve
	RteFlowItemVxlanGpe
	RteFlowItemArpEthIpv4
	RteFlowItemIpv6Ext
	RteFlowItemIcmp6
	RteFlowItemIcmp6NdNs
	RteFlowItemIcmp6NdNa
	RteFlowItemIcmp6NdOpt
	RteFlowItemIcmp6NdOptSlaEth
	RteFlowItemIcmp6NdOptStaEth
	RteFlowItemMark
	RteFlowItemMeta
	RteFlowItemGtpPsc
	RteFlowItemPppoe
	RteFlowItemPppoeProtoId
	RteFlowItemNsh
	RteFlowItemIgmp
	RteFlowItemAh
	RteHigig2Frc
	RteHigig2PptType0
	RteHigig2PptType1
	RteHigig2Hdr
	RteFlowItemHigig2Hdr
	RteFlowItemTag
	RteFlowItemL2Tpv3Oip
	RteFlowItem
	RteFlowActionMark
	RteFlowActionJump
	RteFlowActionQueue
	RteFlowActionCount
	RteFlowQueryCount
	RteFlowActionRss
	RteFlowActionVf
	RteFlowActionPhyPort
	RteFlowActionPortId
	RteFlowActionMeter
	RteFlowActionSecurity
	RteFlowActionOfSetMplsTtl
	RteFlowActionOfSetNwTtl
	RteFlowActionOfPushVlan
	RteFlowActionOfSetVlanVid
	RteFlowActionOfSetVlanPcp
	RteFlowActionOfPopMpls
	RteFlowActionOfPushMpls
	RteFlowActionVxlanEncap
	RteFlowActionNvgreEncap
	RteFlowActionRawEncap
	RteFlowActionRawDecap
	RteFlowActionSetIpv4
	RteFlowActionSetIpv6
	RteFlowActionSetTp
	RteFlowActionSetTtl
	RteFlowActionSetMac
	RteFlowActionSetTag
	RteFlowActionSetMeta
	RteFlowActionSetDscp
	RteFlowAction
	RteFlowError
	RteFlowListResult
	RequestFlowCreate
	RequestFlowofPort
	RequestofPort
	RequestIsolate
	RequestListPorts
	PortsInformation
	ResponseFlow
	ResponseFlowCreate
	ResponseFlowQuery
	ResponseFlowList
	ResponsePortList
*/
package flow

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RteFlowItemType int32

const (
	// *
	// [META]
	//
	// End marker for item lists. Prevents further processing of items;
	// thereby ending the pattern.
	//
	// No associated specification messageure.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_END RteFlowItemType = 0
	// *
	// [META]
	//
	// Used as a placeholder for convenience. It is ignored and simply
	// discarded by PMDs.
	//
	// No associated specification messageure.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_VOID RteFlowItemType = 1
	// *
	// [META]
	//
	// Inverted matching; i.e. process packets that do not match the
	// pattern.
	//
	// No associated specification messageure.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_INVERT RteFlowItemType = 2
	// *
	// Matches any protocol in place of the current layer; a single ANY
	// may also stand for several protocol layers.
	//
	// See message rte_flow_item_any.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ANY RteFlowItemType = 3
	// *
	// [META]
	//
	// Matches traffic originating from (ingress) or going to (egress)
	// the physical function of the current device.
	//
	// No associated specification messageure.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_PF RteFlowItemType = 4
	// *
	// [META]
	//
	// Matches traffic originating from (ingress) or going to (egress) a
	// given virtual function of the current device.
	//
	// See message rte_flow_item_vf.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_VF RteFlowItemType = 5
	// *
	// [META]
	//
	// Matches traffic originating from (ingress) or going to (egress) a
	// physical port of the underlying device.
	//
	// See message rte_flow_item_phy_port.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_PHY_PORT RteFlowItemType = 6
	// *
	// [META]
	//
	// Matches traffic originating from (ingress) or going to (egress) a
	// given DPDK port ID.
	//
	// See message rte_flow_item_port_id.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_PORT_ID RteFlowItemType = 7
	// *
	// Matches a byte string of a given length at a given offset.
	//
	// See message rte_flow_item_raw.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_RAW RteFlowItemType = 8
	// *
	// Matches an Ethernet header.
	//
	// See message rte_flow_item_eth.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ETH RteFlowItemType = 9
	// *
	// Matches an 802.1Q/ad VLAN tag.
	//
	// See message rte_flow_item_vlan.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_VLAN RteFlowItemType = 10
	// *
	// Matches an IPv4 header.
	//
	// See message rte_flow_item_ipv4.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_IPV4 RteFlowItemType = 11
	// *
	// Matches an IPv6 header.
	//
	// See message rte_flow_item_ipv6.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_IPV6 RteFlowItemType = 12
	// *
	// Matches an ICMP header.
	//
	// See message rte_flow_item_icmp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ICMP RteFlowItemType = 13
	// *
	// Matches a UDP header.
	//
	// See message rte_flow_item_udp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_UDP RteFlowItemType = 14
	// *
	// Matches a TCP header.
	//
	// See message rte_flow_item_tcp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_TCP RteFlowItemType = 15
	// *
	// Matches a SCTP header.
	//
	// See message rte_flow_item_sctp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_SCTP RteFlowItemType = 16
	// *
	// Matches a VXLAN header.
	//
	// See message rte_flow_item_vxlan.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_VXLAN RteFlowItemType = 17
	// *
	// Matches a E_TAG header.
	//
	// See message rte_flow_item_e_tag.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_E_TAG RteFlowItemType = 18
	// *
	// Matches a NVGRE header.
	//
	// See message rte_flow_item_nvgre.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_NVGRE RteFlowItemType = 19
	// *
	// Matches a MPLS header.
	//
	// See message rte_flow_item_mpls.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_MPLS RteFlowItemType = 20
	// *
	// Matches a GRE header.
	//
	// See message rte_flow_item_gre.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_GRE RteFlowItemType = 21
	// *
	// [META]
	//
	// Fuzzy pattern match; expect faster than default.
	//
	// This is for device that support fuzzy matching option.
	// Usually a fuzzy matching is fast but the cost is accuracy.
	//
	// See message rte_flow_item_fuzzy.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_FUZZY RteFlowItemType = 22
	// *
	// Matches a GTP header.
	//
	// Configure flow for GTP packets.
	//
	// See message rte_flow_item_gtp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_GTP RteFlowItemType = 23
	// *
	// Matches a GTP header.
	//
	// Configure flow for GTP-C packets.
	//
	// See message rte_flow_item_gtp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_GTPC RteFlowItemType = 24
	// *
	// Matches a GTP header.
	//
	// Configure flow for GTP-U packets.
	//
	// See message rte_flow_item_gtp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_GTPU RteFlowItemType = 25
	// *
	// Matches a ESP header.
	//
	// See message rte_flow_item_esp.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ESP RteFlowItemType = 26
	// *
	// Matches a GENEVE header.
	//
	// See message rte_flow_item_geneve.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_GENEVE RteFlowItemType = 27
	// *
	// Matches a VXLAN-GPE header.
	//
	// See message rte_flow_item_vxlan_gpe.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_VXLAN_GPE RteFlowItemType = 28
	// *
	// Matches an ARP header for Ethernet/IPv4.
	//
	// See message rte_flow_item_arp_eth_ipv4.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4 RteFlowItemType = 29
	// *
	// Matches the presence of any IPv6 extension header.
	//
	// See message rte_flow_item_ipv6_ext.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_IPV6_EXT RteFlowItemType = 30
	// *
	// Matches any ICMPv6 header.
	//
	// See message rte_flow_item_icmp6.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ICMP6 RteFlowItemType = 31
	// *
	// Matches an ICMPv6 neighbor discovery solicitation.
	//
	// See message rte_flow_item_icmp6_nd_ns.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS RteFlowItemType = 32
	// *
	// Matches an ICMPv6 neighbor discovery advertisement.
	//
	// See message rte_flow_item_icmp6_nd_na.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA RteFlowItemType = 33
	// *
	// Matches the presence of any ICMPv6 neighbor discovery option.
	//
	// See message rte_flow_item_icmp6_nd_opt.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT RteFlowItemType = 34
	// *
	// Matches an ICMPv6 neighbor discovery source Ethernet link-layer
	// address option.
	//
	// See message rte_flow_item_icmp6_nd_opt_sla_eth.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH RteFlowItemType = 35
	// *
	// Matches an ICMPv6 neighbor discovery target Ethernet link-layer
	// address option.
	//
	// See message rte_flow_item_icmp6_nd_opt_tla_eth.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH RteFlowItemType = 36
	// *
	// Matches specified mark field.
	//
	// See message rte_flow_item_mark.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_MARK RteFlowItemType = 37
	// *
	// [META]
	//
	// Matches a metadata value.
	//
	// See message rte_flow_item_meta.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_META RteFlowItemType = 38
	// *
	// Matches a GRE optional key field.
	//
	// The value should a big-endian 32bit integer.
	//
	// When this item present the K bit is implicitly matched as "1"
	// in the default mask.
	//
	// @p spec/mask type:
	// @code rte_be32_t * @endcode
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_GRE_KEY RteFlowItemType = 39
	// *
	// Matches a GTP extension header: PDU session container.
	//
	// Configure flow for GTP packets with extension header type 0x85.
	//
	// See message rte_flow_item_gtp_psc.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_GTP_PSC RteFlowItemType = 40
	// *
	// Matches a PPPoE header.
	//
	// Configure flow for PPPoE session packets.
	//
	// See message rte_flow_item_pppoe.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_PPPOES RteFlowItemType = 41
	// *
	// Matches a PPPoE header.
	//
	// Configure flow for PPPoE discovery packets.
	//
	// See message rte_flow_item_pppoe.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_PPPOED RteFlowItemType = 42
	// *
	// Matches a PPPoE optional proto_id field.
	//
	// It only applies to PPPoE session packets.
	//
	// See message rte_flow_item_pppoe_proto_id.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID RteFlowItemType = 43
	// *
	// Matches Network service header (NSH).
	// See message rte_flow_item_nsh.
	//
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_NSH RteFlowItemType = 44
	// *
	// Matches Internet Group Management Protocol (IGMP).
	// See message rte_flow_item_igmp.
	//
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_IGMP RteFlowItemType = 45
	// *
	// Matches IP Authentication Header (AH).
	// See message rte_flow_item_ah.
	//
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_AH RteFlowItemType = 46
	// *
	// Matches a HIGIG header.
	// see message rte_flow_item_higig2_hdr.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_HIGIG2 RteFlowItemType = 47
	//
	// [META]
	//
	// Matches a tag value.
	//
	// See message rte_flow_item_tag.
	RteFlowItemType_RTE_FLOW_ITEM_TYPE_TAG RteFlowItemType = 48
)

var RteFlowItemType_name = map[int32]string{
	0:  "RTE_FLOW_ITEM_TYPE_END",
	1:  "RTE_FLOW_ITEM_TYPE_VOID",
	2:  "RTE_FLOW_ITEM_TYPE_INVERT",
	3:  "RTE_FLOW_ITEM_TYPE_ANY",
	4:  "RTE_FLOW_ITEM_TYPE_PF",
	5:  "RTE_FLOW_ITEM_TYPE_VF",
	6:  "RTE_FLOW_ITEM_TYPE_PHY_PORT",
	7:  "RTE_FLOW_ITEM_TYPE_PORT_ID",
	8:  "RTE_FLOW_ITEM_TYPE_RAW",
	9:  "RTE_FLOW_ITEM_TYPE_ETH",
	10: "RTE_FLOW_ITEM_TYPE_VLAN",
	11: "RTE_FLOW_ITEM_TYPE_IPV4",
	12: "RTE_FLOW_ITEM_TYPE_IPV6",
	13: "RTE_FLOW_ITEM_TYPE_ICMP",
	14: "RTE_FLOW_ITEM_TYPE_UDP",
	15: "RTE_FLOW_ITEM_TYPE_TCP",
	16: "RTE_FLOW_ITEM_TYPE_SCTP",
	17: "RTE_FLOW_ITEM_TYPE_VXLAN",
	18: "RTE_FLOW_ITEM_TYPE_E_TAG",
	19: "RTE_FLOW_ITEM_TYPE_NVGRE",
	20: "RTE_FLOW_ITEM_TYPE_MPLS",
	21: "RTE_FLOW_ITEM_TYPE_GRE",
	22: "RTE_FLOW_ITEM_TYPE_FUZZY",
	23: "RTE_FLOW_ITEM_TYPE_GTP",
	24: "RTE_FLOW_ITEM_TYPE_GTPC",
	25: "RTE_FLOW_ITEM_TYPE_GTPU",
	26: "RTE_FLOW_ITEM_TYPE_ESP",
	27: "RTE_FLOW_ITEM_TYPE_GENEVE",
	28: "RTE_FLOW_ITEM_TYPE_VXLAN_GPE",
	29: "RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4",
	30: "RTE_FLOW_ITEM_TYPE_IPV6_EXT",
	31: "RTE_FLOW_ITEM_TYPE_ICMP6",
	32: "RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS",
	33: "RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA",
	34: "RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT",
	35: "RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH",
	36: "RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH",
	37: "RTE_FLOW_ITEM_TYPE_MARK",
	38: "RTE_FLOW_ITEM_TYPE_META",
	39: "RTE_FLOW_ITEM_TYPE_GRE_KEY",
	40: "RTE_FLOW_ITEM_TYPE_GTP_PSC",
	41: "RTE_FLOW_ITEM_TYPE_PPPOES",
	42: "RTE_FLOW_ITEM_TYPE_PPPOED",
	43: "RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID",
	44: "RTE_FLOW_ITEM_TYPE_NSH",
	45: "RTE_FLOW_ITEM_TYPE_IGMP",
	46: "RTE_FLOW_ITEM_TYPE_AH",
	47: "RTE_FLOW_ITEM_TYPE_HIGIG2",
	48: "RTE_FLOW_ITEM_TYPE_TAG",
}
var RteFlowItemType_value = map[string]int32{
	"RTE_FLOW_ITEM_TYPE_END":                  0,
	"RTE_FLOW_ITEM_TYPE_VOID":                 1,
	"RTE_FLOW_ITEM_TYPE_INVERT":               2,
	"RTE_FLOW_ITEM_TYPE_ANY":                  3,
	"RTE_FLOW_ITEM_TYPE_PF":                   4,
	"RTE_FLOW_ITEM_TYPE_VF":                   5,
	"RTE_FLOW_ITEM_TYPE_PHY_PORT":             6,
	"RTE_FLOW_ITEM_TYPE_PORT_ID":              7,
	"RTE_FLOW_ITEM_TYPE_RAW":                  8,
	"RTE_FLOW_ITEM_TYPE_ETH":                  9,
	"RTE_FLOW_ITEM_TYPE_VLAN":                 10,
	"RTE_FLOW_ITEM_TYPE_IPV4":                 11,
	"RTE_FLOW_ITEM_TYPE_IPV6":                 12,
	"RTE_FLOW_ITEM_TYPE_ICMP":                 13,
	"RTE_FLOW_ITEM_TYPE_UDP":                  14,
	"RTE_FLOW_ITEM_TYPE_TCP":                  15,
	"RTE_FLOW_ITEM_TYPE_SCTP":                 16,
	"RTE_FLOW_ITEM_TYPE_VXLAN":                17,
	"RTE_FLOW_ITEM_TYPE_E_TAG":                18,
	"RTE_FLOW_ITEM_TYPE_NVGRE":                19,
	"RTE_FLOW_ITEM_TYPE_MPLS":                 20,
	"RTE_FLOW_ITEM_TYPE_GRE":                  21,
	"RTE_FLOW_ITEM_TYPE_FUZZY":                22,
	"RTE_FLOW_ITEM_TYPE_GTP":                  23,
	"RTE_FLOW_ITEM_TYPE_GTPC":                 24,
	"RTE_FLOW_ITEM_TYPE_GTPU":                 25,
	"RTE_FLOW_ITEM_TYPE_ESP":                  26,
	"RTE_FLOW_ITEM_TYPE_GENEVE":               27,
	"RTE_FLOW_ITEM_TYPE_VXLAN_GPE":            28,
	"RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4":         29,
	"RTE_FLOW_ITEM_TYPE_IPV6_EXT":             30,
	"RTE_FLOW_ITEM_TYPE_ICMP6":                31,
	"RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS":          32,
	"RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA":          33,
	"RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT":         34,
	"RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH": 35,
	"RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH": 36,
	"RTE_FLOW_ITEM_TYPE_MARK":                 37,
	"RTE_FLOW_ITEM_TYPE_META":                 38,
	"RTE_FLOW_ITEM_TYPE_GRE_KEY":              39,
	"RTE_FLOW_ITEM_TYPE_GTP_PSC":              40,
	"RTE_FLOW_ITEM_TYPE_PPPOES":               41,
	"RTE_FLOW_ITEM_TYPE_PPPOED":               42,
	"RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID":       43,
	"RTE_FLOW_ITEM_TYPE_NSH":                  44,
	"RTE_FLOW_ITEM_TYPE_IGMP":                 45,
	"RTE_FLOW_ITEM_TYPE_AH":                   46,
	"RTE_FLOW_ITEM_TYPE_HIGIG2":               47,
	"RTE_FLOW_ITEM_TYPE_TAG":                  48,
}

func (x RteFlowItemType) String() string {
	return proto.EnumName(RteFlowItemType_name, int32(x))
}
func (RteFlowItemType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type RteEthHashFunction int32

const (
	RteEthHashFunction_RTE_ETH_HASH_FUNCTION_DEFAULT    RteEthHashFunction = 0
	RteEthHashFunction_RTE_ETH_HASH_FUNCTION_TOEPLITZ   RteEthHashFunction = 1
	RteEthHashFunction_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR RteEthHashFunction = 2
	// *
	// Symmetric Toeplitz: src, dst will be replaced by
	// xor(src, dst). For the case with src/dst only,
	// src or dst address will xor with zero pair.
	RteEthHashFunction_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ RteEthHashFunction = 3
	RteEthHashFunction_RTE_ETH_HASH_FUNCTION_MAX                RteEthHashFunction = 4
)

var RteEthHashFunction_name = map[int32]string{
	0: "RTE_ETH_HASH_FUNCTION_DEFAULT",
	1: "RTE_ETH_HASH_FUNCTION_TOEPLITZ",
	2: "RTE_ETH_HASH_FUNCTION_SIMPLE_XOR",
	3: "RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ",
	4: "RTE_ETH_HASH_FUNCTION_MAX",
}
var RteEthHashFunction_value = map[string]int32{
	"RTE_ETH_HASH_FUNCTION_DEFAULT":            0,
	"RTE_ETH_HASH_FUNCTION_TOEPLITZ":           1,
	"RTE_ETH_HASH_FUNCTION_SIMPLE_XOR":         2,
	"RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ": 3,
	"RTE_ETH_HASH_FUNCTION_MAX":                4,
}

func (x RteEthHashFunction) String() string {
	return proto.EnumName(RteEthHashFunction_name, int32(x))
}
func (RteEthHashFunction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type RteFlowActionType int32

const (
	// *
	// End marker for action lists. Prevents further processing of
	// actions; thereby ending the list.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_END RteFlowActionType = 0
	// *
	// Used as a placeholder for convenience. It is ignored and simply
	// discarded by PMDs.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_VOID RteFlowActionType = 1
	// *
	// Leaves traffic up for additional processing by subsequent flow
	// rules; makes a flow rule non-terminating.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_PASSTHRU RteFlowActionType = 2
	// *
	// RTE_FLOW_ACTION_TYPE_JUMP
	//
	// Redirects packets to a group on the current device.
	//
	// See message rte_flow_action_jump.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_JUMP RteFlowActionType = 3
	// *
	// Attaches an integer value to packets and sets PKT_RX_FDIR and
	// PKT_RX_FDIR_ID mbuf flags.
	//
	// See message rte_flow_action_mark.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_MARK RteFlowActionType = 4
	// *
	// Flags packets. Similar to MARK without a specific value; only
	// sets the PKT_RX_FDIR mbuf flag.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_FLAG RteFlowActionType = 5
	// *
	// Assigns packets to a given queue index.
	//
	// See message rte_flow_action_queue.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_QUEUE RteFlowActionType = 6
	// *
	// Drops packets.
	//
	// PASSTHRU overrides this action if both are specified.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_DROP RteFlowActionType = 7
	// *
	// Enables counters for this flow rule.
	//
	// These counters can be retrieved and reset through rte_flow_query();
	// see message rte_flow_query_count.
	//
	// See message rte_flow_action_count.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_COUNT RteFlowActionType = 8
	// *
	// Similar to QUEUE; except RSS is additionally performed on packets
	// to spread them among several queues according to the provided
	// parameters.
	//
	// See message rte_flow_action_rss.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_RSS RteFlowActionType = 9
	// *
	// Directs matching traffic to the physical function (PF) of the
	// current device.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_PF RteFlowActionType = 10
	// *
	// Directs matching traffic to a given virtual function of the
	// current device.
	//
	// See message rte_flow_action_vf.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_VF RteFlowActionType = 11
	// *
	// Directs packets to a given physical port index of the underlying
	// device.
	//
	// See message rte_flow_action_phy_port.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_PHY_PORT RteFlowActionType = 12
	// *
	// Directs matching traffic to a given DPDK port ID.
	//
	// See message rte_flow_action_port_id.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_PORT_ID RteFlowActionType = 13
	// *
	// Traffic metering and policing (MTR).
	//
	// See message rte_flow_action_meter.
	// See file rte_mtr.h for MTR object configuration.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_METER RteFlowActionType = 14
	// *
	// Redirects packets to security engine of current device for security
	// processing as specified by security session.
	//
	// See message rte_flow_action_security.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SECURITY RteFlowActionType = 15
	// *
	// Implements OFPAT_SET_MPLS_TTL ("MPLS TTL") as defined by the
	// OpenFlow Switch Specification.
	//
	// See message rte_flow_action_of_set_mpls_ttl.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL RteFlowActionType = 16
	// *
	// Implements OFPAT_DEC_MPLS_TTL ("decrement MPLS TTL") as defined
	// by the OpenFlow Switch Specification.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_DEC_MPLS_TTL RteFlowActionType = 17
	// *
	// Implements OFPAT_SET_NW_TTL ("IP TTL") as defined by the OpenFlow
	// Switch Specification.
	//
	// See message rte_flow_action_of_set_nw_ttl.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL RteFlowActionType = 18
	// *
	// Implements OFPAT_DEC_NW_TTL ("decrement IP TTL") as defined by
	// the OpenFlow Switch Specification.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL RteFlowActionType = 19
	// *
	// Implements OFPAT_COPY_TTL_OUT ("copy TTL "outwards" -- from
	// next-to-outermost to outermost") as defined by the OpenFlow
	// Switch Specification.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_OUT RteFlowActionType = 20
	// *
	// Implements OFPAT_COPY_TTL_IN ("copy TTL "inwards" -- from
	// outermost to next-to-outermost") as defined by the OpenFlow
	// Switch Specification.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_IN RteFlowActionType = 21
	// *
	// Implements OFPAT_POP_VLAN ("pop the outer VLAN tag") as defined
	// by the OpenFlow Switch Specification.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_POP_VLAN RteFlowActionType = 22
	// *
	// Implements OFPAT_PUSH_VLAN ("push a new VLAN tag") as defined by
	// the OpenFlow Switch Specification.
	//
	// See message rte_flow_action_of_push_vlan.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN RteFlowActionType = 23
	// *
	// Implements OFPAT_SET_VLAN_VID ("set the 802.1q VLAN id") as
	// defined by the OpenFlow Switch Specification.
	//
	// See message rte_flow_action_of_set_vlan_vid.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID RteFlowActionType = 24
	// *
	// Implements OFPAT_SET_LAN_PCP ("set the 802.1q priority") as
	// defined by the OpenFlow Switch Specification.
	//
	// See message rte_flow_action_of_set_vlan_pcp.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP RteFlowActionType = 25
	// *
	// Implements OFPAT_POP_MPLS ("pop the outer MPLS tag") as defined
	// by the OpenFlow Switch Specification.
	//
	// See message rte_flow_action_of_pop_mpls.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_POP_MPLS RteFlowActionType = 26
	// *
	// Implements OFPAT_PUSH_MPLS ("push a new MPLS tag") as defined by
	// the OpenFlow Switch Specification.
	//
	// See message rte_flow_action_of_push_mpls.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS RteFlowActionType = 27
	// *
	// Encapsulate flow in VXLAN tunnel as defined in
	// rte_flow_action_vxlan_encap action messageure.
	//
	// See message rte_flow_action_vxlan_encap.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP RteFlowActionType = 28
	// *
	// Decapsulate outer most VXLAN tunnel from matched flow.
	//
	// If flow pattern does not define a valid VXLAN tunnel (as specified by
	// RFC7348) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION
	// error.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_VXLAN_DECAP RteFlowActionType = 29
	// *
	// Encapsulate flow in NVGRE tunnel defined in the
	// rte_flow_action_nvgre_encap action messageure.
	//
	// See message rte_flow_action_nvgre_encap.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP RteFlowActionType = 30
	// *
	// Decapsulate outer most NVGRE tunnel from matched flow.
	//
	// If flow pattern does not define a valid NVGRE tunnel (as specified by
	// RFC7637) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION
	// error.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_NVGRE_DECAP RteFlowActionType = 31
	// *
	// Add outer header whose template is provided in its data buffer
	//
	// See message rte_flow_action_raw_encap.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_RAW_ENCAP RteFlowActionType = 32
	// *
	// Remove outer header whose template is provided in its data buffer.
	//
	// See message rte_flow_action_raw_decap
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_RAW_DECAP RteFlowActionType = 33
	// *
	// Modify IPv4 source address in the outermost IPv4 header.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4;
	// then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_ipv4.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC RteFlowActionType = 34
	// *
	// Modify IPv4 destination address in the outermost IPv4 header.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4;
	// then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_ipv4.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_IPV4_DST RteFlowActionType = 35
	// *
	// Modify IPv6 source address in the outermost IPv6 header.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6;
	// then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_ipv6.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC RteFlowActionType = 36
	// *
	// Modify IPv6 destination address in the outermost IPv6 header.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6;
	// then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_ipv6.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_IPV6_DST RteFlowActionType = 37
	// *
	// Modify source port number in the outermost TCP/UDP header.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP
	// or RTE_FLOW_ITEM_TYPE_UDP; then the PMD should return a
	// RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_tp.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_TP_SRC RteFlowActionType = 38
	// *
	// Modify destination port number in the outermost TCP/UDP header.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP
	// or RTE_FLOW_ITEM_TYPE_UDP; then the PMD should return a
	// RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_tp.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_TP_DST RteFlowActionType = 39
	// *
	// Swap the source and destination MAC addresses in the outermost
	// Ethernet header.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH;
	// then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_MAC_SWAP RteFlowActionType = 40
	// *
	// Decrease TTL value directly
	//
	// No associated configuration messageure.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_DEC_TTL RteFlowActionType = 41
	// *
	// Set TTL value
	//
	// See message rte_flow_action_set_ttl
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_TTL RteFlowActionType = 42
	// *
	// Set source MAC address from matched flow.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH;
	// the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_mac.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_MAC_SRC RteFlowActionType = 43
	// *
	// Set destination MAC address from matched flow.
	//
	// If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH;
	// the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.
	//
	// See message rte_flow_action_set_mac.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_MAC_DST RteFlowActionType = 44
	// *
	// Increase sequence number in the outermost TCP header.
	//
	// Action configuration specifies the value to increase
	// TCP sequence number as a big-endian 32 bit integer.
	//
	// @p conf type:
	// @code rte_be32_t * @endcode
	//
	// Using this action on non-matching traffic will result in
	// undefined behavior.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ RteFlowActionType = 45
	// *
	// Decrease sequence number in the outermost TCP header.
	//
	// Action configuration specifies the value to decrease
	// TCP sequence number as a big-endian 32 bit integer.
	//
	// @p conf type:
	// @code rte_be32_t * @endcode
	//
	// Using this action on non-matching traffic will result in
	// undefined behavior.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ RteFlowActionType = 46
	// *
	// Increase acknowledgment number in the outermost TCP header.
	//
	// Action configuration specifies the value to increase
	// TCP acknowledgment number as a big-endian 32 bit integer.
	//
	// @p conf type:
	// @code rte_be32_t * @endcode
	//
	// Using this action on non-matching traffic will result in
	// undefined behavior.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_INC_TCP_ACK RteFlowActionType = 47
	// *
	// Decrease acknowledgment number in the outermost TCP header.
	//
	// Action configuration specifies the value to decrease
	// TCP acknowledgment number as a big-endian 32 bit integer.
	//
	// @p conf type:
	// @code rte_be32_t * @endcode
	//
	// Using this action on non-matching traffic will result in
	// undefined behavior.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK RteFlowActionType = 48
	// *
	// Set Tag.
	//
	// Tag is for internal flow usage only and
	// is not delivered to the application.
	//
	// See message rte_flow_action_set_tag.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_TAG RteFlowActionType = 49
	// *
	// Set metadata on ingress or egress path.
	//
	// See message rte_flow_action_set_meta.
	RteFlowActionType_RTE_FLOW_ACTION_TYPE_SET_META RteFlowActionType = 50
)

var RteFlowActionType_name = map[int32]string{
	0:  "RTE_FLOW_ACTION_TYPE_END",
	1:  "RTE_FLOW_ACTION_TYPE_VOID",
	2:  "RTE_FLOW_ACTION_TYPE_PASSTHRU",
	3:  "RTE_FLOW_ACTION_TYPE_JUMP",
	4:  "RTE_FLOW_ACTION_TYPE_MARK",
	5:  "RTE_FLOW_ACTION_TYPE_FLAG",
	6:  "RTE_FLOW_ACTION_TYPE_QUEUE",
	7:  "RTE_FLOW_ACTION_TYPE_DROP",
	8:  "RTE_FLOW_ACTION_TYPE_COUNT",
	9:  "RTE_FLOW_ACTION_TYPE_RSS",
	10: "RTE_FLOW_ACTION_TYPE_PF",
	11: "RTE_FLOW_ACTION_TYPE_VF",
	12: "RTE_FLOW_ACTION_TYPE_PHY_PORT",
	13: "RTE_FLOW_ACTION_TYPE_PORT_ID",
	14: "RTE_FLOW_ACTION_TYPE_METER",
	15: "RTE_FLOW_ACTION_TYPE_SECURITY",
	16: "RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL",
	17: "RTE_FLOW_ACTION_TYPE_OF_DEC_MPLS_TTL",
	18: "RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL",
	19: "RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL",
	20: "RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_OUT",
	21: "RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_IN",
	22: "RTE_FLOW_ACTION_TYPE_OF_POP_VLAN",
	23: "RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN",
	24: "RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID",
	25: "RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP",
	26: "RTE_FLOW_ACTION_TYPE_OF_POP_MPLS",
	27: "RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS",
	28: "RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP",
	29: "RTE_FLOW_ACTION_TYPE_VXLAN_DECAP",
	30: "RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP",
	31: "RTE_FLOW_ACTION_TYPE_NVGRE_DECAP",
	32: "RTE_FLOW_ACTION_TYPE_RAW_ENCAP",
	33: "RTE_FLOW_ACTION_TYPE_RAW_DECAP",
	34: "RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC",
	35: "RTE_FLOW_ACTION_TYPE_SET_IPV4_DST",
	36: "RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC",
	37: "RTE_FLOW_ACTION_TYPE_SET_IPV6_DST",
	38: "RTE_FLOW_ACTION_TYPE_SET_TP_SRC",
	39: "RTE_FLOW_ACTION_TYPE_SET_TP_DST",
	40: "RTE_FLOW_ACTION_TYPE_MAC_SWAP",
	41: "RTE_FLOW_ACTION_TYPE_DEC_TTL",
	42: "RTE_FLOW_ACTION_TYPE_SET_TTL",
	43: "RTE_FLOW_ACTION_TYPE_SET_MAC_SRC",
	44: "RTE_FLOW_ACTION_TYPE_SET_MAC_DST",
	45: "RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ",
	46: "RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ",
	47: "RTE_FLOW_ACTION_TYPE_INC_TCP_ACK",
	48: "RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK",
	49: "RTE_FLOW_ACTION_TYPE_SET_TAG",
	50: "RTE_FLOW_ACTION_TYPE_SET_META",
}
var RteFlowActionType_value = map[string]int32{
	"RTE_FLOW_ACTION_TYPE_END":             0,
	"RTE_FLOW_ACTION_TYPE_VOID":            1,
	"RTE_FLOW_ACTION_TYPE_PASSTHRU":        2,
	"RTE_FLOW_ACTION_TYPE_JUMP":            3,
	"RTE_FLOW_ACTION_TYPE_MARK":            4,
	"RTE_FLOW_ACTION_TYPE_FLAG":            5,
	"RTE_FLOW_ACTION_TYPE_QUEUE":           6,
	"RTE_FLOW_ACTION_TYPE_DROP":            7,
	"RTE_FLOW_ACTION_TYPE_COUNT":           8,
	"RTE_FLOW_ACTION_TYPE_RSS":             9,
	"RTE_FLOW_ACTION_TYPE_PF":              10,
	"RTE_FLOW_ACTION_TYPE_VF":              11,
	"RTE_FLOW_ACTION_TYPE_PHY_PORT":        12,
	"RTE_FLOW_ACTION_TYPE_PORT_ID":         13,
	"RTE_FLOW_ACTION_TYPE_METER":           14,
	"RTE_FLOW_ACTION_TYPE_SECURITY":        15,
	"RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL": 16,
	"RTE_FLOW_ACTION_TYPE_OF_DEC_MPLS_TTL": 17,
	"RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL":   18,
	"RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL":   19,
	"RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_OUT": 20,
	"RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_IN":  21,
	"RTE_FLOW_ACTION_TYPE_OF_POP_VLAN":     22,
	"RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN":    23,
	"RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID": 24,
	"RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP": 25,
	"RTE_FLOW_ACTION_TYPE_OF_POP_MPLS":     26,
	"RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS":    27,
	"RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP":     28,
	"RTE_FLOW_ACTION_TYPE_VXLAN_DECAP":     29,
	"RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP":     30,
	"RTE_FLOW_ACTION_TYPE_NVGRE_DECAP":     31,
	"RTE_FLOW_ACTION_TYPE_RAW_ENCAP":       32,
	"RTE_FLOW_ACTION_TYPE_RAW_DECAP":       33,
	"RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC":    34,
	"RTE_FLOW_ACTION_TYPE_SET_IPV4_DST":    35,
	"RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC":    36,
	"RTE_FLOW_ACTION_TYPE_SET_IPV6_DST":    37,
	"RTE_FLOW_ACTION_TYPE_SET_TP_SRC":      38,
	"RTE_FLOW_ACTION_TYPE_SET_TP_DST":      39,
	"RTE_FLOW_ACTION_TYPE_MAC_SWAP":        40,
	"RTE_FLOW_ACTION_TYPE_DEC_TTL":         41,
	"RTE_FLOW_ACTION_TYPE_SET_TTL":         42,
	"RTE_FLOW_ACTION_TYPE_SET_MAC_SRC":     43,
	"RTE_FLOW_ACTION_TYPE_SET_MAC_DST":     44,
	"RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ":     45,
	"RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ":     46,
	"RTE_FLOW_ACTION_TYPE_INC_TCP_ACK":     47,
	"RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK":     48,
	"RTE_FLOW_ACTION_TYPE_SET_TAG":         49,
	"RTE_FLOW_ACTION_TYPE_SET_META":        50,
}

func (x RteFlowActionType) String() string {
	return proto.EnumName(RteFlowActionType_name, int32(x))
}
func (RteFlowActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type RteFlowErrorType int32

const (
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_NONE          RteFlowErrorType = 0
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_UNSPECIFIED   RteFlowErrorType = 1
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_HANDLE        RteFlowErrorType = 2
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ATTR_GROUP    RteFlowErrorType = 3
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY RteFlowErrorType = 4
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ATTR_INGRESS  RteFlowErrorType = 5
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ATTR_EGRESS   RteFlowErrorType = 6
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER RteFlowErrorType = 7
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ATTR          RteFlowErrorType = 8
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ITEM_NUM      RteFlowErrorType = 9
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ITEM_SPEC     RteFlowErrorType = 10
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ITEM_LAST     RteFlowErrorType = 11
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ITEM_MASK     RteFlowErrorType = 12
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ITEM          RteFlowErrorType = 13
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ACTION_NUM    RteFlowErrorType = 14
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ACTION_CONF   RteFlowErrorType = 15
	RteFlowErrorType_RTE_FLOW_ERROR_TYPE_ACTION        RteFlowErrorType = 16
)

var RteFlowErrorType_name = map[int32]string{
	0:  "RTE_FLOW_ERROR_TYPE_NONE",
	1:  "RTE_FLOW_ERROR_TYPE_UNSPECIFIED",
	2:  "RTE_FLOW_ERROR_TYPE_HANDLE",
	3:  "RTE_FLOW_ERROR_TYPE_ATTR_GROUP",
	4:  "RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY",
	5:  "RTE_FLOW_ERROR_TYPE_ATTR_INGRESS",
	6:  "RTE_FLOW_ERROR_TYPE_ATTR_EGRESS",
	7:  "RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER",
	8:  "RTE_FLOW_ERROR_TYPE_ATTR",
	9:  "RTE_FLOW_ERROR_TYPE_ITEM_NUM",
	10: "RTE_FLOW_ERROR_TYPE_ITEM_SPEC",
	11: "RTE_FLOW_ERROR_TYPE_ITEM_LAST",
	12: "RTE_FLOW_ERROR_TYPE_ITEM_MASK",
	13: "RTE_FLOW_ERROR_TYPE_ITEM",
	14: "RTE_FLOW_ERROR_TYPE_ACTION_NUM",
	15: "RTE_FLOW_ERROR_TYPE_ACTION_CONF",
	16: "RTE_FLOW_ERROR_TYPE_ACTION",
}
var RteFlowErrorType_value = map[string]int32{
	"RTE_FLOW_ERROR_TYPE_NONE":          0,
	"RTE_FLOW_ERROR_TYPE_UNSPECIFIED":   1,
	"RTE_FLOW_ERROR_TYPE_HANDLE":        2,
	"RTE_FLOW_ERROR_TYPE_ATTR_GROUP":    3,
	"RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY": 4,
	"RTE_FLOW_ERROR_TYPE_ATTR_INGRESS":  5,
	"RTE_FLOW_ERROR_TYPE_ATTR_EGRESS":   6,
	"RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER": 7,
	"RTE_FLOW_ERROR_TYPE_ATTR":          8,
	"RTE_FLOW_ERROR_TYPE_ITEM_NUM":      9,
	"RTE_FLOW_ERROR_TYPE_ITEM_SPEC":     10,
	"RTE_FLOW_ERROR_TYPE_ITEM_LAST":     11,
	"RTE_FLOW_ERROR_TYPE_ITEM_MASK":     12,
	"RTE_FLOW_ERROR_TYPE_ITEM":          13,
	"RTE_FLOW_ERROR_TYPE_ACTION_NUM":    14,
	"RTE_FLOW_ERROR_TYPE_ACTION_CONF":   15,
	"RTE_FLOW_ERROR_TYPE_ACTION":        16,
}

func (x RteFlowErrorType) String() string {
	return proto.EnumName(RteFlowErrorType_name, int32(x))
}
func (RteFlowErrorType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type RteFlowAttr struct {
	Group    uint32 `protobuf:"varint,1,opt,name=group" json:"group,omitempty"`
	Priority uint32 `protobuf:"varint,2,opt,name=priority" json:"priority,omitempty"`
	Ingress  uint32 `protobuf:"varint,3,opt,name=ingress" json:"ingress,omitempty"`
	Egress   uint32 `protobuf:"varint,4,opt,name=egress" json:"egress,omitempty"`
	Transfer uint32 `protobuf:"varint,5,opt,name=transfer" json:"transfer,omitempty"`
	Reserved uint32 `protobuf:"varint,6,opt,name=reserved" json:"reserved,omitempty"`
}

func (m *RteFlowAttr) Reset()                    { *m = RteFlowAttr{} }
func (m *RteFlowAttr) String() string            { return proto.CompactTextString(m) }
func (*RteFlowAttr) ProtoMessage()               {}
func (*RteFlowAttr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *RteFlowAttr) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *RteFlowAttr) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *RteFlowAttr) GetIngress() uint32 {
	if m != nil {
		return m.Ingress
	}
	return 0
}

func (m *RteFlowAttr) GetEgress() uint32 {
	if m != nil {
		return m.Egress
	}
	return 0
}

func (m *RteFlowAttr) GetTransfer() uint32 {
	if m != nil {
		return m.Transfer
	}
	return 0
}

func (m *RteFlowAttr) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

type GreKeyDefaultMask struct {
	GreKeyDefaultMask uint32 `protobuf:"varint,1,opt,name=gre_key_default_mask,json=greKeyDefaultMask" json:"gre_key_default_mask,omitempty"`
}

func (m *GreKeyDefaultMask) Reset()                    { *m = GreKeyDefaultMask{} }
func (m *GreKeyDefaultMask) String() string            { return proto.CompactTextString(m) }
func (*GreKeyDefaultMask) ProtoMessage()               {}
func (*GreKeyDefaultMask) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GreKeyDefaultMask) GetGreKeyDefaultMask() uint32 {
	if m != nil {
		return m.GreKeyDefaultMask
	}
	return 0
}

type RteFlowItemAny struct {
	Num uint32 `protobuf:"varint,1,opt,name=num" json:"num,omitempty"`
}

func (m *RteFlowItemAny) Reset()                    { *m = RteFlowItemAny{} }
func (m *RteFlowItemAny) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemAny) ProtoMessage()               {}
func (*RteFlowItemAny) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RteFlowItemAny) GetNum() uint32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type RteFlowItemVf struct {
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *RteFlowItemVf) Reset()                    { *m = RteFlowItemVf{} }
func (m *RteFlowItemVf) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemVf) ProtoMessage()               {}
func (*RteFlowItemVf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RteFlowItemVf) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type RteFlowItemPhyPort struct {
	Index uint32 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
}

func (m *RteFlowItemPhyPort) Reset()                    { *m = RteFlowItemPhyPort{} }
func (m *RteFlowItemPhyPort) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemPhyPort) ProtoMessage()               {}
func (*RteFlowItemPhyPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RteFlowItemPhyPort) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type RteFlowItemPortId struct {
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *RteFlowItemPortId) Reset()                    { *m = RteFlowItemPortId{} }
func (m *RteFlowItemPortId) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemPortId) ProtoMessage()               {}
func (*RteFlowItemPortId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RteFlowItemPortId) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type RteFlowItemRaw struct {
	Relative uint32 `protobuf:"varint,1,opt,name=relative" json:"relative,omitempty"`
	Search   uint32 `protobuf:"varint,2,opt,name=search" json:"search,omitempty"`
	Reserved uint32 `protobuf:"varint,3,opt,name=reserved" json:"reserved,omitempty"`
	Offset   int32  `protobuf:"varint,4,opt,name=offset" json:"offset,omitempty"`
	Limit    uint32 `protobuf:"varint,5,opt,name=limit" json:"limit,omitempty"`
	Length   uint32 `protobuf:"varint,6,opt,name=length" json:"length,omitempty"`
	Pattern  uint32 `protobuf:"varint,7,opt,name=pattern" json:"pattern,omitempty"`
}

func (m *RteFlowItemRaw) Reset()                    { *m = RteFlowItemRaw{} }
func (m *RteFlowItemRaw) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemRaw) ProtoMessage()               {}
func (*RteFlowItemRaw) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *RteFlowItemRaw) GetRelative() uint32 {
	if m != nil {
		return m.Relative
	}
	return 0
}

func (m *RteFlowItemRaw) GetSearch() uint32 {
	if m != nil {
		return m.Search
	}
	return 0
}

func (m *RteFlowItemRaw) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowItemRaw) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *RteFlowItemRaw) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RteFlowItemRaw) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *RteFlowItemRaw) GetPattern() uint32 {
	if m != nil {
		return m.Pattern
	}
	return 0
}

type RteEtherAddr struct {
	AddrBytes []byte `protobuf:"bytes,1,opt,name=addr_bytes,json=addrBytes,proto3" json:"addr_bytes,omitempty"`
}

func (m *RteEtherAddr) Reset()                    { *m = RteEtherAddr{} }
func (m *RteEtherAddr) String() string            { return proto.CompactTextString(m) }
func (*RteEtherAddr) ProtoMessage()               {}
func (*RteEtherAddr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RteEtherAddr) GetAddrBytes() []byte {
	if m != nil {
		return m.AddrBytes
	}
	return nil
}

type RteFlowItemEth struct {
	Dst  *RteEtherAddr `protobuf:"bytes,1,opt,name=dst" json:"dst,omitempty"`
	Src  *RteEtherAddr `protobuf:"bytes,2,opt,name=src" json:"src,omitempty"`
	Type uint32        `protobuf:"varint,3,opt,name=type" json:"type,omitempty"`
}

func (m *RteFlowItemEth) Reset()                    { *m = RteFlowItemEth{} }
func (m *RteFlowItemEth) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemEth) ProtoMessage()               {}
func (*RteFlowItemEth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RteFlowItemEth) GetDst() *RteEtherAddr {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *RteFlowItemEth) GetSrc() *RteEtherAddr {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *RteFlowItemEth) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type RteFlowItemVlan struct {
	Tci       uint32 `protobuf:"varint,1,opt,name=tci" json:"tci,omitempty"`
	InnerType uint32 `protobuf:"varint,2,opt,name=inner_type,json=innerType" json:"inner_type,omitempty"`
}

func (m *RteFlowItemVlan) Reset()                    { *m = RteFlowItemVlan{} }
func (m *RteFlowItemVlan) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemVlan) ProtoMessage()               {}
func (*RteFlowItemVlan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RteFlowItemVlan) GetTci() uint32 {
	if m != nil {
		return m.Tci
	}
	return 0
}

func (m *RteFlowItemVlan) GetInnerType() uint32 {
	if m != nil {
		return m.InnerType
	}
	return 0
}

type RteIpv4Hdr struct {
	VersionIhl     uint32 `protobuf:"varint,1,opt,name=version_ihl,json=versionIhl" json:"version_ihl,omitempty"`
	TypeOfService  uint32 `protobuf:"varint,2,opt,name=type_of_service,json=typeOfService" json:"type_of_service,omitempty"`
	TotalLength    uint32 `protobuf:"varint,3,opt,name=total_length,json=totalLength" json:"total_length,omitempty"`
	PacketId       uint32 `protobuf:"varint,4,opt,name=packet_id,json=packetId" json:"packet_id,omitempty"`
	FragmentOffset uint32 `protobuf:"varint,5,opt,name=fragment_offset,json=fragmentOffset" json:"fragment_offset,omitempty"`
	TimeToLive     uint32 `protobuf:"varint,6,opt,name=time_to_live,json=timeToLive" json:"time_to_live,omitempty"`
	NextProtoId    uint32 `protobuf:"varint,7,opt,name=next_proto_id,json=nextProtoId" json:"next_proto_id,omitempty"`
	HdrChecksum    uint32 `protobuf:"varint,8,opt,name=hdr_checksum,json=hdrChecksum" json:"hdr_checksum,omitempty"`
	SrcAddr        uint32 `protobuf:"varint,9,opt,name=src_addr,json=srcAddr" json:"src_addr,omitempty"`
	DstAddr        uint32 `protobuf:"varint,10,opt,name=dst_addr,json=dstAddr" json:"dst_addr,omitempty"`
}

func (m *RteIpv4Hdr) Reset()                    { *m = RteIpv4Hdr{} }
func (m *RteIpv4Hdr) String() string            { return proto.CompactTextString(m) }
func (*RteIpv4Hdr) ProtoMessage()               {}
func (*RteIpv4Hdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *RteIpv4Hdr) GetVersionIhl() uint32 {
	if m != nil {
		return m.VersionIhl
	}
	return 0
}

func (m *RteIpv4Hdr) GetTypeOfService() uint32 {
	if m != nil {
		return m.TypeOfService
	}
	return 0
}

func (m *RteIpv4Hdr) GetTotalLength() uint32 {
	if m != nil {
		return m.TotalLength
	}
	return 0
}

func (m *RteIpv4Hdr) GetPacketId() uint32 {
	if m != nil {
		return m.PacketId
	}
	return 0
}

func (m *RteIpv4Hdr) GetFragmentOffset() uint32 {
	if m != nil {
		return m.FragmentOffset
	}
	return 0
}

func (m *RteIpv4Hdr) GetTimeToLive() uint32 {
	if m != nil {
		return m.TimeToLive
	}
	return 0
}

func (m *RteIpv4Hdr) GetNextProtoId() uint32 {
	if m != nil {
		return m.NextProtoId
	}
	return 0
}

func (m *RteIpv4Hdr) GetHdrChecksum() uint32 {
	if m != nil {
		return m.HdrChecksum
	}
	return 0
}

func (m *RteIpv4Hdr) GetSrcAddr() uint32 {
	if m != nil {
		return m.SrcAddr
	}
	return 0
}

func (m *RteIpv4Hdr) GetDstAddr() uint32 {
	if m != nil {
		return m.DstAddr
	}
	return 0
}

type RteFlowItemIpv4 struct {
	Hdr *RteIpv4Hdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemIpv4) Reset()                    { *m = RteFlowItemIpv4{} }
func (m *RteFlowItemIpv4) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIpv4) ProtoMessage()               {}
func (*RteFlowItemIpv4) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RteFlowItemIpv4) GetHdr() *RteIpv4Hdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteIpv6Hdr struct {
	VtcFlow    uint32 `protobuf:"varint,1,opt,name=vtc_flow,json=vtcFlow" json:"vtc_flow,omitempty"`
	PayloadLen uint32 `protobuf:"varint,2,opt,name=payload_len,json=payloadLen" json:"payload_len,omitempty"`
	Proto      uint32 `protobuf:"varint,3,opt,name=proto" json:"proto,omitempty"`
	HopLimits  uint32 `protobuf:"varint,4,opt,name=hop_limits,json=hopLimits" json:"hop_limits,omitempty"`
	SrcAddr    []byte `protobuf:"bytes,5,opt,name=src_addr,json=srcAddr,proto3" json:"src_addr,omitempty"`
	DstAddr    []byte `protobuf:"bytes,6,opt,name=dst_addr,json=dstAddr,proto3" json:"dst_addr,omitempty"`
}

func (m *RteIpv6Hdr) Reset()                    { *m = RteIpv6Hdr{} }
func (m *RteIpv6Hdr) String() string            { return proto.CompactTextString(m) }
func (*RteIpv6Hdr) ProtoMessage()               {}
func (*RteIpv6Hdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *RteIpv6Hdr) GetVtcFlow() uint32 {
	if m != nil {
		return m.VtcFlow
	}
	return 0
}

func (m *RteIpv6Hdr) GetPayloadLen() uint32 {
	if m != nil {
		return m.PayloadLen
	}
	return 0
}

func (m *RteIpv6Hdr) GetProto() uint32 {
	if m != nil {
		return m.Proto
	}
	return 0
}

func (m *RteIpv6Hdr) GetHopLimits() uint32 {
	if m != nil {
		return m.HopLimits
	}
	return 0
}

func (m *RteIpv6Hdr) GetSrcAddr() []byte {
	if m != nil {
		return m.SrcAddr
	}
	return nil
}

func (m *RteIpv6Hdr) GetDstAddr() []byte {
	if m != nil {
		return m.DstAddr
	}
	return nil
}

type RteFlowItemIpv6 struct {
	Hdr *RteIpv6Hdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemIpv6) Reset()                    { *m = RteFlowItemIpv6{} }
func (m *RteFlowItemIpv6) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIpv6) ProtoMessage()               {}
func (*RteFlowItemIpv6) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RteFlowItemIpv6) GetHdr() *RteIpv6Hdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteIcmpHdr struct {
	IcmpType  uint32 `protobuf:"varint,1,opt,name=icmp_type,json=icmpType" json:"icmp_type,omitempty"`
	IcmpCode  uint32 `protobuf:"varint,2,opt,name=icmp_code,json=icmpCode" json:"icmp_code,omitempty"`
	IcmpCksum uint32 `protobuf:"varint,3,opt,name=icmp_cksum,json=icmpCksum" json:"icmp_cksum,omitempty"`
	IcmpIdent uint32 `protobuf:"varint,4,opt,name=icmp_ident,json=icmpIdent" json:"icmp_ident,omitempty"`
	IcmpSeqNb uint32 `protobuf:"varint,5,opt,name=icmp_seq_nb,json=icmpSeqNb" json:"icmp_seq_nb,omitempty"`
}

func (m *RteIcmpHdr) Reset()                    { *m = RteIcmpHdr{} }
func (m *RteIcmpHdr) String() string            { return proto.CompactTextString(m) }
func (*RteIcmpHdr) ProtoMessage()               {}
func (*RteIcmpHdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RteIcmpHdr) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

func (m *RteIcmpHdr) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

func (m *RteIcmpHdr) GetIcmpCksum() uint32 {
	if m != nil {
		return m.IcmpCksum
	}
	return 0
}

func (m *RteIcmpHdr) GetIcmpIdent() uint32 {
	if m != nil {
		return m.IcmpIdent
	}
	return 0
}

func (m *RteIcmpHdr) GetIcmpSeqNb() uint32 {
	if m != nil {
		return m.IcmpSeqNb
	}
	return 0
}

type RteFlowItemIcmp struct {
	Hdr *RteIcmpHdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemIcmp) Reset()                    { *m = RteFlowItemIcmp{} }
func (m *RteFlowItemIcmp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIcmp) ProtoMessage()               {}
func (*RteFlowItemIcmp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *RteFlowItemIcmp) GetHdr() *RteIcmpHdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteUdpHdr struct {
	SrcPort    uint32 `protobuf:"varint,1,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	DstPort    uint32 `protobuf:"varint,2,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	DgramLen   uint32 `protobuf:"varint,3,opt,name=dgram_len,json=dgramLen" json:"dgram_len,omitempty"`
	DgramCksum uint32 `protobuf:"varint,4,opt,name=dgram_cksum,json=dgramCksum" json:"dgram_cksum,omitempty"`
}

func (m *RteUdpHdr) Reset()                    { *m = RteUdpHdr{} }
func (m *RteUdpHdr) String() string            { return proto.CompactTextString(m) }
func (*RteUdpHdr) ProtoMessage()               {}
func (*RteUdpHdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *RteUdpHdr) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *RteUdpHdr) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *RteUdpHdr) GetDgramLen() uint32 {
	if m != nil {
		return m.DgramLen
	}
	return 0
}

func (m *RteUdpHdr) GetDgramCksum() uint32 {
	if m != nil {
		return m.DgramCksum
	}
	return 0
}

type RteFlowItemUdp struct {
	Hdr *RteUdpHdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemUdp) Reset()                    { *m = RteFlowItemUdp{} }
func (m *RteFlowItemUdp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemUdp) ProtoMessage()               {}
func (*RteFlowItemUdp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *RteFlowItemUdp) GetHdr() *RteUdpHdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteTcpHdr struct {
	SrcPort  uint32 `protobuf:"varint,1,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	DstPort  uint32 `protobuf:"varint,2,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	SentSeq  uint32 `protobuf:"varint,3,opt,name=sent_seq,json=sentSeq" json:"sent_seq,omitempty"`
	RecvAck  uint32 `protobuf:"varint,4,opt,name=recv_ack,json=recvAck" json:"recv_ack,omitempty"`
	DataOff  uint32 `protobuf:"varint,5,opt,name=data_off,json=dataOff" json:"data_off,omitempty"`
	TcpFlags uint32 `protobuf:"varint,6,opt,name=tcp_flags,json=tcpFlags" json:"tcp_flags,omitempty"`
	RxWin    uint32 `protobuf:"varint,7,opt,name=rx_win,json=rxWin" json:"rx_win,omitempty"`
	Cksum    uint32 `protobuf:"varint,8,opt,name=cksum" json:"cksum,omitempty"`
	TcpUrp   uint32 `protobuf:"varint,9,opt,name=tcp_urp,json=tcpUrp" json:"tcp_urp,omitempty"`
}

func (m *RteTcpHdr) Reset()                    { *m = RteTcpHdr{} }
func (m *RteTcpHdr) String() string            { return proto.CompactTextString(m) }
func (*RteTcpHdr) ProtoMessage()               {}
func (*RteTcpHdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *RteTcpHdr) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *RteTcpHdr) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *RteTcpHdr) GetSentSeq() uint32 {
	if m != nil {
		return m.SentSeq
	}
	return 0
}

func (m *RteTcpHdr) GetRecvAck() uint32 {
	if m != nil {
		return m.RecvAck
	}
	return 0
}

func (m *RteTcpHdr) GetDataOff() uint32 {
	if m != nil {
		return m.DataOff
	}
	return 0
}

func (m *RteTcpHdr) GetTcpFlags() uint32 {
	if m != nil {
		return m.TcpFlags
	}
	return 0
}

func (m *RteTcpHdr) GetRxWin() uint32 {
	if m != nil {
		return m.RxWin
	}
	return 0
}

func (m *RteTcpHdr) GetCksum() uint32 {
	if m != nil {
		return m.Cksum
	}
	return 0
}

func (m *RteTcpHdr) GetTcpUrp() uint32 {
	if m != nil {
		return m.TcpUrp
	}
	return 0
}

type RteFlowItemTcp struct {
	Hdr *RteTcpHdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemTcp) Reset()                    { *m = RteFlowItemTcp{} }
func (m *RteFlowItemTcp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemTcp) ProtoMessage()               {}
func (*RteFlowItemTcp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *RteFlowItemTcp) GetHdr() *RteTcpHdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteSctpHdr struct {
	SrcPort uint32 `protobuf:"varint,1,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	DstPort uint32 `protobuf:"varint,2,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	Tag     uint32 `protobuf:"varint,3,opt,name=tag" json:"tag,omitempty"`
	Cksum   uint32 `protobuf:"varint,4,opt,name=cksum" json:"cksum,omitempty"`
}

func (m *RteSctpHdr) Reset()                    { *m = RteSctpHdr{} }
func (m *RteSctpHdr) String() string            { return proto.CompactTextString(m) }
func (*RteSctpHdr) ProtoMessage()               {}
func (*RteSctpHdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *RteSctpHdr) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *RteSctpHdr) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *RteSctpHdr) GetTag() uint32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *RteSctpHdr) GetCksum() uint32 {
	if m != nil {
		return m.Cksum
	}
	return 0
}

type RteFlowItemSctp struct {
	Hdr *RteSctpHdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemSctp) Reset()                    { *m = RteFlowItemSctp{} }
func (m *RteFlowItemSctp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemSctp) ProtoMessage()               {}
func (*RteFlowItemSctp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *RteFlowItemSctp) GetHdr() *RteSctpHdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteFlowItemVxlan struct {
	Flags uint32 `protobuf:"varint,1,opt,name=flags" json:"flags,omitempty"`
	Rsvd0 []byte `protobuf:"bytes,2,opt,name=rsvd0,proto3" json:"rsvd0,omitempty"`
	Vni   []byte `protobuf:"bytes,3,opt,name=vni,proto3" json:"vni,omitempty"`
	Rsvd1 uint32 `protobuf:"varint,4,opt,name=rsvd1" json:"rsvd1,omitempty"`
}

func (m *RteFlowItemVxlan) Reset()                    { *m = RteFlowItemVxlan{} }
func (m *RteFlowItemVxlan) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemVxlan) ProtoMessage()               {}
func (*RteFlowItemVxlan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *RteFlowItemVxlan) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RteFlowItemVxlan) GetRsvd0() []byte {
	if m != nil {
		return m.Rsvd0
	}
	return nil
}

func (m *RteFlowItemVxlan) GetVni() []byte {
	if m != nil {
		return m.Vni
	}
	return nil
}

func (m *RteFlowItemVxlan) GetRsvd1() uint32 {
	if m != nil {
		return m.Rsvd1
	}
	return 0
}

type RteFlowItemETag struct {
	// *
	// E-Tag control information (E-TCI).
	// E-PCP (3b), E-DEI (1b), ingress E-CID base (12b).
	EpcpEdeiInEcidB uint32 `protobuf:"varint,1,opt,name=epcp_edei_in_ecid_b,json=epcpEdeiInEcidB" json:"epcp_edei_in_ecid_b,omitempty"`
	// * Reserved (2b), GRP (2b), E-CID base (12b).
	RsvdGrpEcidB uint32 `protobuf:"varint,2,opt,name=rsvd_grp_ecid_b,json=rsvdGrpEcidB" json:"rsvd_grp_ecid_b,omitempty"`
	InEcidE      uint32 `protobuf:"varint,3,opt,name=in_ecid_e,json=inEcidE" json:"in_ecid_e,omitempty"`
	EcidE        uint32 `protobuf:"varint,4,opt,name=ecid_e,json=ecidE" json:"ecid_e,omitempty"`
	InnerType    uint32 `protobuf:"varint,5,opt,name=inner_type,json=innerType" json:"inner_type,omitempty"`
}

func (m *RteFlowItemETag) Reset()                    { *m = RteFlowItemETag{} }
func (m *RteFlowItemETag) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemETag) ProtoMessage()               {}
func (*RteFlowItemETag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *RteFlowItemETag) GetEpcpEdeiInEcidB() uint32 {
	if m != nil {
		return m.EpcpEdeiInEcidB
	}
	return 0
}

func (m *RteFlowItemETag) GetRsvdGrpEcidB() uint32 {
	if m != nil {
		return m.RsvdGrpEcidB
	}
	return 0
}

func (m *RteFlowItemETag) GetInEcidE() uint32 {
	if m != nil {
		return m.InEcidE
	}
	return 0
}

func (m *RteFlowItemETag) GetEcidE() uint32 {
	if m != nil {
		return m.EcidE
	}
	return 0
}

func (m *RteFlowItemETag) GetInnerType() uint32 {
	if m != nil {
		return m.InnerType
	}
	return 0
}

type RteFlowItemNvgre struct {
	// *
	// Checksum (1b), undefined (1b), key bit (1b), sequence number (1b),
	// reserved 0 (9b), version (3b).
	//
	// c_k_s_rsvd0_ver must have value 0x2000 according to RFC 7637.
	CKSRsvd0Ver uint32 `protobuf:"varint,1,opt,name=c_k_s_rsvd0_ver,json=cKSRsvd0Ver" json:"c_k_s_rsvd0_ver,omitempty"`
	Protocol    uint32 `protobuf:"varint,2,opt,name=protocol" json:"protocol,omitempty"`
	Tni         []byte `protobuf:"bytes,3,opt,name=tni,proto3" json:"tni,omitempty"`
	FlowId      uint32 `protobuf:"varint,4,opt,name=flow_id,json=flowId" json:"flow_id,omitempty"`
}

func (m *RteFlowItemNvgre) Reset()                    { *m = RteFlowItemNvgre{} }
func (m *RteFlowItemNvgre) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemNvgre) ProtoMessage()               {}
func (*RteFlowItemNvgre) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *RteFlowItemNvgre) GetCKSRsvd0Ver() uint32 {
	if m != nil {
		return m.CKSRsvd0Ver
	}
	return 0
}

func (m *RteFlowItemNvgre) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *RteFlowItemNvgre) GetTni() []byte {
	if m != nil {
		return m.Tni
	}
	return nil
}

func (m *RteFlowItemNvgre) GetFlowId() uint32 {
	if m != nil {
		return m.FlowId
	}
	return 0
}

type RteFlowItemMpls struct {
	// *
	// Label (20b), TC (3b), Bottom of Stack (1b).
	LabelTcS []byte `protobuf:"bytes,1,opt,name=label_tc_s,json=labelTcS,proto3" json:"label_tc_s,omitempty"`
	Ttl      uint32 `protobuf:"varint,2,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *RteFlowItemMpls) Reset()                    { *m = RteFlowItemMpls{} }
func (m *RteFlowItemMpls) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemMpls) ProtoMessage()               {}
func (*RteFlowItemMpls) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *RteFlowItemMpls) GetLabelTcS() []byte {
	if m != nil {
		return m.LabelTcS
	}
	return nil
}

func (m *RteFlowItemMpls) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type RteFlowItemGre struct {
	// *
	// Checksum (1b), reserved 0 (12b), version (3b).
	// Refer to RFC 2784.
	CRsvd0Ver uint32 `protobuf:"varint,1,opt,name=c_rsvd0_ver,json=cRsvd0Ver" json:"c_rsvd0_ver,omitempty"`
	Protocol  uint32 `protobuf:"varint,2,opt,name=protocol" json:"protocol,omitempty"`
}

func (m *RteFlowItemGre) Reset()                    { *m = RteFlowItemGre{} }
func (m *RteFlowItemGre) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemGre) ProtoMessage()               {}
func (*RteFlowItemGre) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *RteFlowItemGre) GetCRsvd0Ver() uint32 {
	if m != nil {
		return m.CRsvd0Ver
	}
	return 0
}

func (m *RteFlowItemGre) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

type RteFlowItemFuzzy struct {
	Thresh uint32 `protobuf:"varint,1,opt,name=thresh" json:"thresh,omitempty"`
}

func (m *RteFlowItemFuzzy) Reset()                    { *m = RteFlowItemFuzzy{} }
func (m *RteFlowItemFuzzy) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemFuzzy) ProtoMessage()               {}
func (*RteFlowItemFuzzy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *RteFlowItemFuzzy) GetThresh() uint32 {
	if m != nil {
		return m.Thresh
	}
	return 0
}

type RteFlowItemGtp struct {
	// *
	// Version (3b), protocol type (1b), reserved (1b),
	// Extension header flag (1b),
	// Sequence number flag (1b),
	// N-PDU number flag (1b).
	VPtRsvFlags uint32 `protobuf:"varint,1,opt,name=v_pt_rsv_flags,json=vPtRsvFlags" json:"v_pt_rsv_flags,omitempty"`
	MsgType     uint32 `protobuf:"varint,2,opt,name=msg_type,json=msgType" json:"msg_type,omitempty"`
	MsgLen      uint32 `protobuf:"varint,3,opt,name=msg_len,json=msgLen" json:"msg_len,omitempty"`
	Teid        uint32 `protobuf:"varint,4,opt,name=teid" json:"teid,omitempty"`
}

func (m *RteFlowItemGtp) Reset()                    { *m = RteFlowItemGtp{} }
func (m *RteFlowItemGtp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemGtp) ProtoMessage()               {}
func (*RteFlowItemGtp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *RteFlowItemGtp) GetVPtRsvFlags() uint32 {
	if m != nil {
		return m.VPtRsvFlags
	}
	return 0
}

func (m *RteFlowItemGtp) GetMsgType() uint32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *RteFlowItemGtp) GetMsgLen() uint32 {
	if m != nil {
		return m.MsgLen
	}
	return 0
}

func (m *RteFlowItemGtp) GetTeid() uint32 {
	if m != nil {
		return m.Teid
	}
	return 0
}

type RteEspHdr struct {
	Spi uint32 `protobuf:"varint,1,opt,name=spi" json:"spi,omitempty"`
	Seq uint32 `protobuf:"varint,2,opt,name=seq" json:"seq,omitempty"`
}

func (m *RteEspHdr) Reset()                    { *m = RteEspHdr{} }
func (m *RteEspHdr) String() string            { return proto.CompactTextString(m) }
func (*RteEspHdr) ProtoMessage()               {}
func (*RteEspHdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *RteEspHdr) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

func (m *RteEspHdr) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type RteFlowItemEsp struct {
	Hdr *RteEspHdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemEsp) Reset()                    { *m = RteFlowItemEsp{} }
func (m *RteFlowItemEsp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemEsp) ProtoMessage()               {}
func (*RteFlowItemEsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *RteFlowItemEsp) GetHdr() *RteEspHdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteFlowItemGeneve struct {
	// *
	// Version (2b), length of the options fields (6b), OAM packet (1b),
	// critical options present (1b), reserved 0 (6b).
	VerOptLenOCRsvd0 uint32 `protobuf:"varint,1,opt,name=ver_opt_len_o_c_rsvd0,json=verOptLenOCRsvd0" json:"ver_opt_len_o_c_rsvd0,omitempty"`
	Protocol         uint32 `protobuf:"varint,2,opt,name=protocol" json:"protocol,omitempty"`
	Vni              []byte `protobuf:"bytes,3,opt,name=vni,proto3" json:"vni,omitempty"`
	Rsvd1            uint32 `protobuf:"varint,4,opt,name=rsvd1" json:"rsvd1,omitempty"`
}

func (m *RteFlowItemGeneve) Reset()                    { *m = RteFlowItemGeneve{} }
func (m *RteFlowItemGeneve) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemGeneve) ProtoMessage()               {}
func (*RteFlowItemGeneve) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *RteFlowItemGeneve) GetVerOptLenOCRsvd0() uint32 {
	if m != nil {
		return m.VerOptLenOCRsvd0
	}
	return 0
}

func (m *RteFlowItemGeneve) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *RteFlowItemGeneve) GetVni() []byte {
	if m != nil {
		return m.Vni
	}
	return nil
}

func (m *RteFlowItemGeneve) GetRsvd1() uint32 {
	if m != nil {
		return m.Rsvd1
	}
	return 0
}

type RteFlowItemVxlanGpe struct {
	Flags    uint32 `protobuf:"varint,1,opt,name=flags" json:"flags,omitempty"`
	Rsvd0    []byte `protobuf:"bytes,2,opt,name=rsvd0,proto3" json:"rsvd0,omitempty"`
	Protocol uint32 `protobuf:"varint,3,opt,name=protocol" json:"protocol,omitempty"`
	Vni      []byte `protobuf:"bytes,4,opt,name=vni,proto3" json:"vni,omitempty"`
	Rsvd1    uint32 `protobuf:"varint,5,opt,name=rsvd1" json:"rsvd1,omitempty"`
}

func (m *RteFlowItemVxlanGpe) Reset()                    { *m = RteFlowItemVxlanGpe{} }
func (m *RteFlowItemVxlanGpe) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemVxlanGpe) ProtoMessage()               {}
func (*RteFlowItemVxlanGpe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *RteFlowItemVxlanGpe) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RteFlowItemVxlanGpe) GetRsvd0() []byte {
	if m != nil {
		return m.Rsvd0
	}
	return nil
}

func (m *RteFlowItemVxlanGpe) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *RteFlowItemVxlanGpe) GetVni() []byte {
	if m != nil {
		return m.Vni
	}
	return nil
}

func (m *RteFlowItemVxlanGpe) GetRsvd1() uint32 {
	if m != nil {
		return m.Rsvd1
	}
	return 0
}

type RteFlowItemArpEthIpv4 struct {
	Hrd uint32        `protobuf:"varint,1,opt,name=hrd" json:"hrd,omitempty"`
	Pro uint32        `protobuf:"varint,2,opt,name=pro" json:"pro,omitempty"`
	Hln uint32        `protobuf:"varint,3,opt,name=hln" json:"hln,omitempty"`
	Pln uint32        `protobuf:"varint,4,opt,name=pln" json:"pln,omitempty"`
	Op  uint32        `protobuf:"varint,5,opt,name=op" json:"op,omitempty"`
	Sha *RteEtherAddr `protobuf:"bytes,6,opt,name=sha" json:"sha,omitempty"`
	Spa uint32        `protobuf:"varint,7,opt,name=spa" json:"spa,omitempty"`
	Tha *RteEtherAddr `protobuf:"bytes,8,opt,name=tha" json:"tha,omitempty"`
	Tpa uint32        `protobuf:"varint,9,opt,name=tpa" json:"tpa,omitempty"`
}

func (m *RteFlowItemArpEthIpv4) Reset()                    { *m = RteFlowItemArpEthIpv4{} }
func (m *RteFlowItemArpEthIpv4) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemArpEthIpv4) ProtoMessage()               {}
func (*RteFlowItemArpEthIpv4) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *RteFlowItemArpEthIpv4) GetHrd() uint32 {
	if m != nil {
		return m.Hrd
	}
	return 0
}

func (m *RteFlowItemArpEthIpv4) GetPro() uint32 {
	if m != nil {
		return m.Pro
	}
	return 0
}

func (m *RteFlowItemArpEthIpv4) GetHln() uint32 {
	if m != nil {
		return m.Hln
	}
	return 0
}

func (m *RteFlowItemArpEthIpv4) GetPln() uint32 {
	if m != nil {
		return m.Pln
	}
	return 0
}

func (m *RteFlowItemArpEthIpv4) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *RteFlowItemArpEthIpv4) GetSha() *RteEtherAddr {
	if m != nil {
		return m.Sha
	}
	return nil
}

func (m *RteFlowItemArpEthIpv4) GetSpa() uint32 {
	if m != nil {
		return m.Spa
	}
	return 0
}

func (m *RteFlowItemArpEthIpv4) GetTha() *RteEtherAddr {
	if m != nil {
		return m.Tha
	}
	return nil
}

func (m *RteFlowItemArpEthIpv4) GetTpa() uint32 {
	if m != nil {
		return m.Tpa
	}
	return 0
}

type RteFlowItemIpv6Ext struct {
	NextHdr uint32 `protobuf:"varint,1,opt,name=next_hdr,json=nextHdr" json:"next_hdr,omitempty"`
}

func (m *RteFlowItemIpv6Ext) Reset()                    { *m = RteFlowItemIpv6Ext{} }
func (m *RteFlowItemIpv6Ext) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIpv6Ext) ProtoMessage()               {}
func (*RteFlowItemIpv6Ext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *RteFlowItemIpv6Ext) GetNextHdr() uint32 {
	if m != nil {
		return m.NextHdr
	}
	return 0
}

type RteFlowItemIcmp6 struct {
	Type     uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Code     uint32 `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	Checksum uint32 `protobuf:"varint,3,opt,name=checksum" json:"checksum,omitempty"`
}

func (m *RteFlowItemIcmp6) Reset()                    { *m = RteFlowItemIcmp6{} }
func (m *RteFlowItemIcmp6) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIcmp6) ProtoMessage()               {}
func (*RteFlowItemIcmp6) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *RteFlowItemIcmp6) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RteFlowItemIcmp6) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RteFlowItemIcmp6) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

type RteFlowItemIcmp6NdNs struct {
	Type       uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Code       uint32 `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	Checksum   uint32 `protobuf:"varint,3,opt,name=checksum" json:"checksum,omitempty"`
	Reserved   uint32 `protobuf:"varint,4,opt,name=reserved" json:"reserved,omitempty"`
	TargetAddr []byte `protobuf:"bytes,5,opt,name=target_addr,json=targetAddr,proto3" json:"target_addr,omitempty"`
}

func (m *RteFlowItemIcmp6NdNs) Reset()                    { *m = RteFlowItemIcmp6NdNs{} }
func (m *RteFlowItemIcmp6NdNs) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIcmp6NdNs) ProtoMessage()               {}
func (*RteFlowItemIcmp6NdNs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *RteFlowItemIcmp6NdNs) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNs) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNs) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNs) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNs) GetTargetAddr() []byte {
	if m != nil {
		return m.TargetAddr
	}
	return nil
}

type RteFlowItemIcmp6NdNa struct {
	Type     uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Code     uint32 `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	Checksum uint32 `protobuf:"varint,3,opt,name=checksum" json:"checksum,omitempty"`
	// *
	// Route flag (1b), solicited flag (1b), override flag (1b),
	// reserved (29b).
	RsoReserved uint32 `protobuf:"varint,4,opt,name=rso_reserved,json=rsoReserved" json:"rso_reserved,omitempty"`
	TargetAddr  []byte `protobuf:"bytes,5,opt,name=target_addr,json=targetAddr,proto3" json:"target_addr,omitempty"`
}

func (m *RteFlowItemIcmp6NdNa) Reset()                    { *m = RteFlowItemIcmp6NdNa{} }
func (m *RteFlowItemIcmp6NdNa) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIcmp6NdNa) ProtoMessage()               {}
func (*RteFlowItemIcmp6NdNa) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *RteFlowItemIcmp6NdNa) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNa) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNa) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNa) GetRsoReserved() uint32 {
	if m != nil {
		return m.RsoReserved
	}
	return 0
}

func (m *RteFlowItemIcmp6NdNa) GetTargetAddr() []byte {
	if m != nil {
		return m.TargetAddr
	}
	return nil
}

type RteFlowItemIcmp6NdOpt struct {
	Type   uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Length uint32 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
}

func (m *RteFlowItemIcmp6NdOpt) Reset()                    { *m = RteFlowItemIcmp6NdOpt{} }
func (m *RteFlowItemIcmp6NdOpt) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIcmp6NdOpt) ProtoMessage()               {}
func (*RteFlowItemIcmp6NdOpt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *RteFlowItemIcmp6NdOpt) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RteFlowItemIcmp6NdOpt) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

type RteFlowItemIcmp6NdOptSlaEth struct {
	Type   uint32        `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Length uint32        `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Sla    *RteEtherAddr `protobuf:"bytes,3,opt,name=sla" json:"sla,omitempty"`
}

func (m *RteFlowItemIcmp6NdOptSlaEth) Reset()                    { *m = RteFlowItemIcmp6NdOptSlaEth{} }
func (m *RteFlowItemIcmp6NdOptSlaEth) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIcmp6NdOptSlaEth) ProtoMessage()               {}
func (*RteFlowItemIcmp6NdOptSlaEth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *RteFlowItemIcmp6NdOptSlaEth) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RteFlowItemIcmp6NdOptSlaEth) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *RteFlowItemIcmp6NdOptSlaEth) GetSla() *RteEtherAddr {
	if m != nil {
		return m.Sla
	}
	return nil
}

type RteFlowItemIcmp6NdOptStaEth struct {
	Type   uint32        `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Length uint32        `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Tla    *RteEtherAddr `protobuf:"bytes,3,opt,name=tla" json:"tla,omitempty"`
}

func (m *RteFlowItemIcmp6NdOptStaEth) Reset()                    { *m = RteFlowItemIcmp6NdOptStaEth{} }
func (m *RteFlowItemIcmp6NdOptStaEth) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIcmp6NdOptStaEth) ProtoMessage()               {}
func (*RteFlowItemIcmp6NdOptStaEth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *RteFlowItemIcmp6NdOptStaEth) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RteFlowItemIcmp6NdOptStaEth) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *RteFlowItemIcmp6NdOptStaEth) GetTla() *RteEtherAddr {
	if m != nil {
		return m.Tla
	}
	return nil
}

type RteFlowItemMark struct {
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *RteFlowItemMark) Reset()                    { *m = RteFlowItemMark{} }
func (m *RteFlowItemMark) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemMark) ProtoMessage()               {}
func (*RteFlowItemMark) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *RteFlowItemMark) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type RteFlowItemMeta struct {
	Data uint32 `protobuf:"varint,1,opt,name=data" json:"data,omitempty"`
}

func (m *RteFlowItemMeta) Reset()                    { *m = RteFlowItemMeta{} }
func (m *RteFlowItemMeta) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemMeta) ProtoMessage()               {}
func (*RteFlowItemMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *RteFlowItemMeta) GetData() uint32 {
	if m != nil {
		return m.Data
	}
	return 0
}

type RteFlowItemGtpPsc struct {
	PduType uint32 `protobuf:"varint,1,opt,name=pdu_type,json=pduType" json:"pdu_type,omitempty"`
	Qfi     uint32 `protobuf:"varint,2,opt,name=qfi" json:"qfi,omitempty"`
}

func (m *RteFlowItemGtpPsc) Reset()                    { *m = RteFlowItemGtpPsc{} }
func (m *RteFlowItemGtpPsc) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemGtpPsc) ProtoMessage()               {}
func (*RteFlowItemGtpPsc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *RteFlowItemGtpPsc) GetPduType() uint32 {
	if m != nil {
		return m.PduType
	}
	return 0
}

func (m *RteFlowItemGtpPsc) GetQfi() uint32 {
	if m != nil {
		return m.Qfi
	}
	return 0
}

type RteFlowItemPppoe struct {
	// *
	// Version (4b), type (4b).
	VersionType uint32 `protobuf:"varint,1,opt,name=version_type,json=versionType" json:"version_type,omitempty"`
	Code        uint32 `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	SessionId   uint32 `protobuf:"varint,3,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Length      uint32 `protobuf:"varint,4,opt,name=length" json:"length,omitempty"`
}

func (m *RteFlowItemPppoe) Reset()                    { *m = RteFlowItemPppoe{} }
func (m *RteFlowItemPppoe) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemPppoe) ProtoMessage()               {}
func (*RteFlowItemPppoe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *RteFlowItemPppoe) GetVersionType() uint32 {
	if m != nil {
		return m.VersionType
	}
	return 0
}

func (m *RteFlowItemPppoe) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RteFlowItemPppoe) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *RteFlowItemPppoe) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

type RteFlowItemPppoeProtoId struct {
	ProtoId uint32 `protobuf:"varint,1,opt,name=proto_id,json=protoId" json:"proto_id,omitempty"`
}

func (m *RteFlowItemPppoeProtoId) Reset()                    { *m = RteFlowItemPppoeProtoId{} }
func (m *RteFlowItemPppoeProtoId) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemPppoeProtoId) ProtoMessage()               {}
func (*RteFlowItemPppoeProtoId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *RteFlowItemPppoeProtoId) GetProtoId() uint32 {
	if m != nil {
		return m.ProtoId
	}
	return 0
}

type RteFlowItemNsh struct {
	Version   uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	OamPkt    uint32 `protobuf:"varint,2,opt,name=oam_pkt,json=oamPkt" json:"oam_pkt,omitempty"`
	Reserved  uint32 `protobuf:"varint,3,opt,name=reserved" json:"reserved,omitempty"`
	Ttl       uint32 `protobuf:"varint,4,opt,name=ttl" json:"ttl,omitempty"`
	Length    uint32 `protobuf:"varint,5,opt,name=length" json:"length,omitempty"`
	Reserved1 uint32 `protobuf:"varint,6,opt,name=reserved1" json:"reserved1,omitempty"`
	Mdtype    uint32 `protobuf:"varint,7,opt,name=mdtype" json:"mdtype,omitempty"`
	NextProto uint32 `protobuf:"varint,8,opt,name=next_proto,json=nextProto" json:"next_proto,omitempty"`
	Spi       uint32 `protobuf:"varint,9,opt,name=spi" json:"spi,omitempty"`
	Sindex    uint32 `protobuf:"varint,10,opt,name=sindex" json:"sindex,omitempty"`
}

func (m *RteFlowItemNsh) Reset()                    { *m = RteFlowItemNsh{} }
func (m *RteFlowItemNsh) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemNsh) ProtoMessage()               {}
func (*RteFlowItemNsh) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *RteFlowItemNsh) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *RteFlowItemNsh) GetOamPkt() uint32 {
	if m != nil {
		return m.OamPkt
	}
	return 0
}

func (m *RteFlowItemNsh) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowItemNsh) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RteFlowItemNsh) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *RteFlowItemNsh) GetReserved1() uint32 {
	if m != nil {
		return m.Reserved1
	}
	return 0
}

func (m *RteFlowItemNsh) GetMdtype() uint32 {
	if m != nil {
		return m.Mdtype
	}
	return 0
}

func (m *RteFlowItemNsh) GetNextProto() uint32 {
	if m != nil {
		return m.NextProto
	}
	return 0
}

func (m *RteFlowItemNsh) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

func (m *RteFlowItemNsh) GetSindex() uint32 {
	if m != nil {
		return m.Sindex
	}
	return 0
}

type RteFlowItemIgmp struct {
	Type        uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	MaxRespTime uint32 `protobuf:"varint,2,opt,name=max_resp_time,json=maxRespTime" json:"max_resp_time,omitempty"`
	Checksum    uint32 `protobuf:"varint,3,opt,name=checksum" json:"checksum,omitempty"`
	GroupAddr   uint32 `protobuf:"varint,4,opt,name=group_addr,json=groupAddr" json:"group_addr,omitempty"`
}

func (m *RteFlowItemIgmp) Reset()                    { *m = RteFlowItemIgmp{} }
func (m *RteFlowItemIgmp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemIgmp) ProtoMessage()               {}
func (*RteFlowItemIgmp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *RteFlowItemIgmp) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RteFlowItemIgmp) GetMaxRespTime() uint32 {
	if m != nil {
		return m.MaxRespTime
	}
	return 0
}

func (m *RteFlowItemIgmp) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *RteFlowItemIgmp) GetGroupAddr() uint32 {
	if m != nil {
		return m.GroupAddr
	}
	return 0
}

type RteFlowItemAh struct {
	NextHdr    uint32 `protobuf:"varint,1,opt,name=next_hdr,json=nextHdr" json:"next_hdr,omitempty"`
	PayloadLen uint32 `protobuf:"varint,2,opt,name=payload_len,json=payloadLen" json:"payload_len,omitempty"`
	Reserved   uint32 `protobuf:"varint,3,opt,name=reserved" json:"reserved,omitempty"`
	Spi        uint32 `protobuf:"varint,4,opt,name=spi" json:"spi,omitempty"`
	SeqNum     uint32 `protobuf:"varint,5,opt,name=seq_num,json=seqNum" json:"seq_num,omitempty"`
}

func (m *RteFlowItemAh) Reset()                    { *m = RteFlowItemAh{} }
func (m *RteFlowItemAh) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemAh) ProtoMessage()               {}
func (*RteFlowItemAh) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *RteFlowItemAh) GetNextHdr() uint32 {
	if m != nil {
		return m.NextHdr
	}
	return 0
}

func (m *RteFlowItemAh) GetPayloadLen() uint32 {
	if m != nil {
		return m.PayloadLen
	}
	return 0
}

func (m *RteFlowItemAh) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowItemAh) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

func (m *RteFlowItemAh) GetSeqNum() uint32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

type RteHigig2Frc struct {
	Ksop     uint32 `protobuf:"varint,1,opt,name=ksop" json:"ksop,omitempty"`
	Tc       uint32 `protobuf:"varint,2,opt,name=tc" json:"tc,omitempty"`
	Mcst     uint32 `protobuf:"varint,3,opt,name=mcst" json:"mcst,omitempty"`
	Resv     uint32 `protobuf:"varint,4,opt,name=resv" json:"resv,omitempty"`
	DstModid uint32 `protobuf:"varint,5,opt,name=dst_modid,json=dstModid" json:"dst_modid,omitempty"`
	DstPid   uint32 `protobuf:"varint,6,opt,name=dst_pid,json=dstPid" json:"dst_pid,omitempty"`
	SrcModid uint32 `protobuf:"varint,7,opt,name=src_modid,json=srcModid" json:"src_modid,omitempty"`
	SrcPid   uint32 `protobuf:"varint,8,opt,name=src_pid,json=srcPid" json:"src_pid,omitempty"`
	Lbid     uint32 `protobuf:"varint,9,opt,name=lbid" json:"lbid,omitempty"`
	PpdType  uint32 `protobuf:"varint,11,opt,name=ppd_type,json=ppdType" json:"ppd_type,omitempty"`
	Resv1    uint32 `protobuf:"varint,12,opt,name=resv1" json:"resv1,omitempty"`
	Dp       uint32 `protobuf:"varint,13,opt,name=dp" json:"dp,omitempty"`
}

func (m *RteHigig2Frc) Reset()                    { *m = RteHigig2Frc{} }
func (m *RteHigig2Frc) String() string            { return proto.CompactTextString(m) }
func (*RteHigig2Frc) ProtoMessage()               {}
func (*RteHigig2Frc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *RteHigig2Frc) GetKsop() uint32 {
	if m != nil {
		return m.Ksop
	}
	return 0
}

func (m *RteHigig2Frc) GetTc() uint32 {
	if m != nil {
		return m.Tc
	}
	return 0
}

func (m *RteHigig2Frc) GetMcst() uint32 {
	if m != nil {
		return m.Mcst
	}
	return 0
}

func (m *RteHigig2Frc) GetResv() uint32 {
	if m != nil {
		return m.Resv
	}
	return 0
}

func (m *RteHigig2Frc) GetDstModid() uint32 {
	if m != nil {
		return m.DstModid
	}
	return 0
}

func (m *RteHigig2Frc) GetDstPid() uint32 {
	if m != nil {
		return m.DstPid
	}
	return 0
}

func (m *RteHigig2Frc) GetSrcModid() uint32 {
	if m != nil {
		return m.SrcModid
	}
	return 0
}

func (m *RteHigig2Frc) GetSrcPid() uint32 {
	if m != nil {
		return m.SrcPid
	}
	return 0
}

func (m *RteHigig2Frc) GetLbid() uint32 {
	if m != nil {
		return m.Lbid
	}
	return 0
}

func (m *RteHigig2Frc) GetPpdType() uint32 {
	if m != nil {
		return m.PpdType
	}
	return 0
}

func (m *RteHigig2Frc) GetResv1() uint32 {
	if m != nil {
		return m.Resv1
	}
	return 0
}

func (m *RteHigig2Frc) GetDp() uint32 {
	if m != nil {
		return m.Dp
	}
	return 0
}

type RteHigig2PptType0 struct {
	Mirror        uint32 `protobuf:"varint,1,opt,name=mirror" json:"mirror,omitempty"`
	MirrorDone    uint32 `protobuf:"varint,2,opt,name=mirror_done,json=mirrorDone" json:"mirror_done,omitempty"`
	MirrorOnly    uint32 `protobuf:"varint,3,opt,name=mirror_only,json=mirrorOnly" json:"mirror_only,omitempty"`
	IngressTagged uint32 `protobuf:"varint,4,opt,name=ingress_tagged,json=ingressTagged" json:"ingress_tagged,omitempty"`
	DstTgid       uint32 `protobuf:"varint,5,opt,name=dst_tgid,json=dstTgid" json:"dst_tgid,omitempty"`
	DstT          uint32 `protobuf:"varint,6,opt,name=dst_t,json=dstT" json:"dst_t,omitempty"`
	VcLabel2      uint32 `protobuf:"varint,7,opt,name=vc_label2,json=vcLabel2" json:"vc_label2,omitempty"`
	LabelPresent  uint32 `protobuf:"varint,8,opt,name=label_present,json=labelPresent" json:"label_present,omitempty"`
	L3            uint32 `protobuf:"varint,9,opt,name=l3" json:"l3,omitempty"`
	Res           uint32 `protobuf:"varint,10,opt,name=res" json:"res,omitempty"`
	VcLabel1      uint32 `protobuf:"varint,11,opt,name=vc_label1,json=vcLabel1" json:"vc_label1,omitempty"`
	VcLabel0      uint32 `protobuf:"varint,12,opt,name=vc_label0,json=vcLabel0" json:"vc_label0,omitempty"`
	VidHigh       uint32 `protobuf:"varint,13,opt,name=vid_high,json=vidHigh" json:"vid_high,omitempty"`
	VidLow        uint32 `protobuf:"varint,14,opt,name=vid_low,json=vidLow" json:"vid_low,omitempty"`
	Opc           uint32 `protobuf:"varint,15,opt,name=opc" json:"opc,omitempty"`
	Res1          uint32 `protobuf:"varint,16,opt,name=res1" json:"res1,omitempty"`
	SrceT         uint32 `protobuf:"varint,17,opt,name=srce_t,json=srceT" json:"srce_t,omitempty"`
	Pf            uint32 `protobuf:"varint,18,opt,name=pf" json:"pf,omitempty"`
	Res2          uint32 `protobuf:"varint,19,opt,name=res2" json:"res2,omitempty"`
	HdrExtLength  uint32 `protobuf:"varint,20,opt,name=hdr_ext_length,json=hdrExtLength" json:"hdr_ext_length,omitempty"`
}

func (m *RteHigig2PptType0) Reset()                    { *m = RteHigig2PptType0{} }
func (m *RteHigig2PptType0) String() string            { return proto.CompactTextString(m) }
func (*RteHigig2PptType0) ProtoMessage()               {}
func (*RteHigig2PptType0) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *RteHigig2PptType0) GetMirror() uint32 {
	if m != nil {
		return m.Mirror
	}
	return 0
}

func (m *RteHigig2PptType0) GetMirrorDone() uint32 {
	if m != nil {
		return m.MirrorDone
	}
	return 0
}

func (m *RteHigig2PptType0) GetMirrorOnly() uint32 {
	if m != nil {
		return m.MirrorOnly
	}
	return 0
}

func (m *RteHigig2PptType0) GetIngressTagged() uint32 {
	if m != nil {
		return m.IngressTagged
	}
	return 0
}

func (m *RteHigig2PptType0) GetDstTgid() uint32 {
	if m != nil {
		return m.DstTgid
	}
	return 0
}

func (m *RteHigig2PptType0) GetDstT() uint32 {
	if m != nil {
		return m.DstT
	}
	return 0
}

func (m *RteHigig2PptType0) GetVcLabel2() uint32 {
	if m != nil {
		return m.VcLabel2
	}
	return 0
}

func (m *RteHigig2PptType0) GetLabelPresent() uint32 {
	if m != nil {
		return m.LabelPresent
	}
	return 0
}

func (m *RteHigig2PptType0) GetL3() uint32 {
	if m != nil {
		return m.L3
	}
	return 0
}

func (m *RteHigig2PptType0) GetRes() uint32 {
	if m != nil {
		return m.Res
	}
	return 0
}

func (m *RteHigig2PptType0) GetVcLabel1() uint32 {
	if m != nil {
		return m.VcLabel1
	}
	return 0
}

func (m *RteHigig2PptType0) GetVcLabel0() uint32 {
	if m != nil {
		return m.VcLabel0
	}
	return 0
}

func (m *RteHigig2PptType0) GetVidHigh() uint32 {
	if m != nil {
		return m.VidHigh
	}
	return 0
}

func (m *RteHigig2PptType0) GetVidLow() uint32 {
	if m != nil {
		return m.VidLow
	}
	return 0
}

func (m *RteHigig2PptType0) GetOpc() uint32 {
	if m != nil {
		return m.Opc
	}
	return 0
}

func (m *RteHigig2PptType0) GetRes1() uint32 {
	if m != nil {
		return m.Res1
	}
	return 0
}

func (m *RteHigig2PptType0) GetSrceT() uint32 {
	if m != nil {
		return m.SrceT
	}
	return 0
}

func (m *RteHigig2PptType0) GetPf() uint32 {
	if m != nil {
		return m.Pf
	}
	return 0
}

func (m *RteHigig2PptType0) GetRes2() uint32 {
	if m != nil {
		return m.Res2
	}
	return 0
}

func (m *RteHigig2PptType0) GetHdrExtLength() uint32 {
	if m != nil {
		return m.HdrExtLength
	}
	return 0
}

type RteHigig2PptType1 struct {
	Classification uint32 `protobuf:"varint,1,opt,name=classification" json:"classification,omitempty"`
	Resv           uint32 `protobuf:"varint,2,opt,name=resv" json:"resv,omitempty"`
	Vid            uint32 `protobuf:"varint,3,opt,name=vid" json:"vid,omitempty"`
	Opcode         uint32 `protobuf:"varint,4,opt,name=opcode" json:"opcode,omitempty"`
	Resv1          uint32 `protobuf:"varint,5,opt,name=resv1" json:"resv1,omitempty"`
	SrcT           uint32 `protobuf:"varint,6,opt,name=src_t,json=srcT" json:"src_t,omitempty"`
	Pfm            uint32 `protobuf:"varint,7,opt,name=pfm" json:"pfm,omitempty"`
	Resv2          uint32 `protobuf:"varint,8,opt,name=resv2" json:"resv2,omitempty"`
	HdrExtLen      uint32 `protobuf:"varint,9,opt,name=hdr_ext_len,json=hdrExtLen" json:"hdr_ext_len,omitempty"`
}

func (m *RteHigig2PptType1) Reset()                    { *m = RteHigig2PptType1{} }
func (m *RteHigig2PptType1) String() string            { return proto.CompactTextString(m) }
func (*RteHigig2PptType1) ProtoMessage()               {}
func (*RteHigig2PptType1) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *RteHigig2PptType1) GetClassification() uint32 {
	if m != nil {
		return m.Classification
	}
	return 0
}

func (m *RteHigig2PptType1) GetResv() uint32 {
	if m != nil {
		return m.Resv
	}
	return 0
}

func (m *RteHigig2PptType1) GetVid() uint32 {
	if m != nil {
		return m.Vid
	}
	return 0
}

func (m *RteHigig2PptType1) GetOpcode() uint32 {
	if m != nil {
		return m.Opcode
	}
	return 0
}

func (m *RteHigig2PptType1) GetResv1() uint32 {
	if m != nil {
		return m.Resv1
	}
	return 0
}

func (m *RteHigig2PptType1) GetSrcT() uint32 {
	if m != nil {
		return m.SrcT
	}
	return 0
}

func (m *RteHigig2PptType1) GetPfm() uint32 {
	if m != nil {
		return m.Pfm
	}
	return 0
}

func (m *RteHigig2PptType1) GetResv2() uint32 {
	if m != nil {
		return m.Resv2
	}
	return 0
}

func (m *RteHigig2PptType1) GetHdrExtLen() uint32 {
	if m != nil {
		return m.HdrExtLen
	}
	return 0
}

type RteHigig2Hdr struct {
	Fcr  *RteHigig2Frc      `protobuf:"bytes,1,opt,name=fcr" json:"fcr,omitempty"`
	Ppt0 *RteHigig2PptType0 `protobuf:"bytes,2,opt,name=ppt0" json:"ppt0,omitempty"`
	Ppt1 *RteHigig2PptType1 `protobuf:"bytes,3,opt,name=ppt1" json:"ppt1,omitempty"`
}

func (m *RteHigig2Hdr) Reset()                    { *m = RteHigig2Hdr{} }
func (m *RteHigig2Hdr) String() string            { return proto.CompactTextString(m) }
func (*RteHigig2Hdr) ProtoMessage()               {}
func (*RteHigig2Hdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *RteHigig2Hdr) GetFcr() *RteHigig2Frc {
	if m != nil {
		return m.Fcr
	}
	return nil
}

func (m *RteHigig2Hdr) GetPpt0() *RteHigig2PptType0 {
	if m != nil {
		return m.Ppt0
	}
	return nil
}

func (m *RteHigig2Hdr) GetPpt1() *RteHigig2PptType1 {
	if m != nil {
		return m.Ppt1
	}
	return nil
}

type RteFlowItemHigig2Hdr struct {
	Hdr *RteHigig2Hdr `protobuf:"bytes,1,opt,name=hdr" json:"hdr,omitempty"`
}

func (m *RteFlowItemHigig2Hdr) Reset()                    { *m = RteFlowItemHigig2Hdr{} }
func (m *RteFlowItemHigig2Hdr) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemHigig2Hdr) ProtoMessage()               {}
func (*RteFlowItemHigig2Hdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *RteFlowItemHigig2Hdr) GetHdr() *RteHigig2Hdr {
	if m != nil {
		return m.Hdr
	}
	return nil
}

type RteFlowItemTag struct {
	Data  uint32 `protobuf:"varint,1,opt,name=data" json:"data,omitempty"`
	Index uint32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *RteFlowItemTag) Reset()                    { *m = RteFlowItemTag{} }
func (m *RteFlowItemTag) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemTag) ProtoMessage()               {}
func (*RteFlowItemTag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *RteFlowItemTag) GetData() uint32 {
	if m != nil {
		return m.Data
	}
	return 0
}

func (m *RteFlowItemTag) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type RteFlowItemL2Tpv3Oip struct {
	SessionId uint32 `protobuf:"varint,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *RteFlowItemL2Tpv3Oip) Reset()                    { *m = RteFlowItemL2Tpv3Oip{} }
func (m *RteFlowItemL2Tpv3Oip) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItemL2Tpv3Oip) ProtoMessage()               {}
func (*RteFlowItemL2Tpv3Oip) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *RteFlowItemL2Tpv3Oip) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

type RteFlowItem struct {
	Type RteFlowItemType      `protobuf:"varint,1,opt,name=type,enum=flow.RteFlowItemType" json:"type,omitempty"`
	Spec *google_protobuf.Any `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Last *google_protobuf.Any `protobuf:"bytes,3,opt,name=last" json:"last,omitempty"`
	Mask *google_protobuf.Any `protobuf:"bytes,4,opt,name=mask" json:"mask,omitempty"`
}

func (m *RteFlowItem) Reset()                    { *m = RteFlowItem{} }
func (m *RteFlowItem) String() string            { return proto.CompactTextString(m) }
func (*RteFlowItem) ProtoMessage()               {}
func (*RteFlowItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *RteFlowItem) GetType() RteFlowItemType {
	if m != nil {
		return m.Type
	}
	return RteFlowItemType_RTE_FLOW_ITEM_TYPE_END
}

func (m *RteFlowItem) GetSpec() *google_protobuf.Any {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *RteFlowItem) GetLast() *google_protobuf.Any {
	if m != nil {
		return m.Last
	}
	return nil
}

func (m *RteFlowItem) GetMask() *google_protobuf.Any {
	if m != nil {
		return m.Mask
	}
	return nil
}

type RteFlowActionMark struct {
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *RteFlowActionMark) Reset()                    { *m = RteFlowActionMark{} }
func (m *RteFlowActionMark) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionMark) ProtoMessage()               {}
func (*RteFlowActionMark) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *RteFlowActionMark) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type RteFlowActionJump struct {
	Group uint32 `protobuf:"varint,1,opt,name=group" json:"group,omitempty"`
}

func (m *RteFlowActionJump) Reset()                    { *m = RteFlowActionJump{} }
func (m *RteFlowActionJump) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionJump) ProtoMessage()               {}
func (*RteFlowActionJump) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *RteFlowActionJump) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

type RteFlowActionQueue struct {
	Index uint32 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
}

func (m *RteFlowActionQueue) Reset()                    { *m = RteFlowActionQueue{} }
func (m *RteFlowActionQueue) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionQueue) ProtoMessage()               {}
func (*RteFlowActionQueue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *RteFlowActionQueue) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type RteFlowActionCount struct {
	Shared   uint32 `protobuf:"varint,1,opt,name=shared" json:"shared,omitempty"`
	Reserved uint32 `protobuf:"varint,2,opt,name=reserved" json:"reserved,omitempty"`
	Id       uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
}

func (m *RteFlowActionCount) Reset()                    { *m = RteFlowActionCount{} }
func (m *RteFlowActionCount) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionCount) ProtoMessage()               {}
func (*RteFlowActionCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *RteFlowActionCount) GetShared() uint32 {
	if m != nil {
		return m.Shared
	}
	return 0
}

func (m *RteFlowActionCount) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowActionCount) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type RteFlowQueryCount struct {
	Reset_   uint32 `protobuf:"varint,1,opt,name=reset" json:"reset,omitempty"`
	HitsSet  uint32 `protobuf:"varint,2,opt,name=hits_set,json=hitsSet" json:"hits_set,omitempty"`
	BytesSet uint32 `protobuf:"varint,3,opt,name=bytes_set,json=bytesSet" json:"bytes_set,omitempty"`
	Reserved uint32 `protobuf:"varint,4,opt,name=reserved" json:"reserved,omitempty"`
	Hits     uint64 `protobuf:"varint,5,opt,name=hits" json:"hits,omitempty"`
	Bytes    uint64 `protobuf:"varint,6,opt,name=bytes" json:"bytes,omitempty"`
}

func (m *RteFlowQueryCount) Reset()                    { *m = RteFlowQueryCount{} }
func (m *RteFlowQueryCount) String() string            { return proto.CompactTextString(m) }
func (*RteFlowQueryCount) ProtoMessage()               {}
func (*RteFlowQueryCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *RteFlowQueryCount) GetReset_() uint32 {
	if m != nil {
		return m.Reset_
	}
	return 0
}

func (m *RteFlowQueryCount) GetHitsSet() uint32 {
	if m != nil {
		return m.HitsSet
	}
	return 0
}

func (m *RteFlowQueryCount) GetBytesSet() uint32 {
	if m != nil {
		return m.BytesSet
	}
	return 0
}

func (m *RteFlowQueryCount) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowQueryCount) GetHits() uint64 {
	if m != nil {
		return m.Hits
	}
	return 0
}

func (m *RteFlowQueryCount) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type RteFlowActionRss struct {
	Func RteEthHashFunction `protobuf:"varint,1,opt,name=func,enum=flow.RteEthHashFunction" json:"func,omitempty"`
	// *
	// Packet encapsulation level RSS hash @p types apply to.
	//
	// - @p 0 requests the default behavior. Depending on the packet
	//   type, it can mean outermost, innermost, anything in between or
	//   even no RSS.
	//
	//   It basically stands for the innermost encapsulation level RSS
	//   can be performed on according to PMD and device capabilities.
	//
	// - @p 1 requests RSS to be performed on the outermost packet
	//   encapsulation level.
	//
	// - @p 2 and subsequent values request RSS to be performed on the
	//   specified inner packet encapsulation level, from outermost to
	//   innermost (lower to higher values).
	//
	// Values other than @p 0 are not necessarily supported.
	//
	// Requesting a specific RSS level on unrecognized traffic results
	// in undefined behavior. For predictable results, it is recommended
	// to make the flow rule pattern match packet headers up to the
	// requested encapsulation level so that only matching traffic goes
	// through.
	Level    uint32 `protobuf:"varint,2,opt,name=level" json:"level,omitempty"`
	Types    uint64 `protobuf:"varint,3,opt,name=types" json:"types,omitempty"`
	KeyLen   uint32 `protobuf:"varint,4,opt,name=key_len,json=keyLen" json:"key_len,omitempty"`
	QueueNum uint32 `protobuf:"varint,5,opt,name=queue_num,json=queueNum" json:"queue_num,omitempty"`
	Key      uint32 `protobuf:"varint,6,opt,name=key" json:"key,omitempty"`
	Queue    uint32 `protobuf:"varint,7,opt,name=queue" json:"queue,omitempty"`
}

func (m *RteFlowActionRss) Reset()                    { *m = RteFlowActionRss{} }
func (m *RteFlowActionRss) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionRss) ProtoMessage()               {}
func (*RteFlowActionRss) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

func (m *RteFlowActionRss) GetFunc() RteEthHashFunction {
	if m != nil {
		return m.Func
	}
	return RteEthHashFunction_RTE_ETH_HASH_FUNCTION_DEFAULT
}

func (m *RteFlowActionRss) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *RteFlowActionRss) GetTypes() uint64 {
	if m != nil {
		return m.Types
	}
	return 0
}

func (m *RteFlowActionRss) GetKeyLen() uint32 {
	if m != nil {
		return m.KeyLen
	}
	return 0
}

func (m *RteFlowActionRss) GetQueueNum() uint32 {
	if m != nil {
		return m.QueueNum
	}
	return 0
}

func (m *RteFlowActionRss) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *RteFlowActionRss) GetQueue() uint32 {
	if m != nil {
		return m.Queue
	}
	return 0
}

type RteFlowActionVf struct {
	Reserved uint32 `protobuf:"varint,1,opt,name=reserved" json:"reserved,omitempty"`
	Original uint32 `protobuf:"varint,2,opt,name=original" json:"original,omitempty"`
	Id       uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
}

func (m *RteFlowActionVf) Reset()                    { *m = RteFlowActionVf{} }
func (m *RteFlowActionVf) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionVf) ProtoMessage()               {}
func (*RteFlowActionVf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

func (m *RteFlowActionVf) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowActionVf) GetOriginal() uint32 {
	if m != nil {
		return m.Original
	}
	return 0
}

func (m *RteFlowActionVf) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type RteFlowActionPhyPort struct {
	Original uint32 `protobuf:"varint,1,opt,name=original" json:"original,omitempty"`
	Reserved uint32 `protobuf:"varint,2,opt,name=reserved" json:"reserved,omitempty"`
	Index    uint32 `protobuf:"varint,3,opt,name=index" json:"index,omitempty"`
}

func (m *RteFlowActionPhyPort) Reset()                    { *m = RteFlowActionPhyPort{} }
func (m *RteFlowActionPhyPort) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionPhyPort) ProtoMessage()               {}
func (*RteFlowActionPhyPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *RteFlowActionPhyPort) GetOriginal() uint32 {
	if m != nil {
		return m.Original
	}
	return 0
}

func (m *RteFlowActionPhyPort) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowActionPhyPort) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type RteFlowActionPortId struct {
	Original uint32 `protobuf:"varint,1,opt,name=original" json:"original,omitempty"`
	Reserved uint32 `protobuf:"varint,2,opt,name=reserved" json:"reserved,omitempty"`
	Id       uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
}

func (m *RteFlowActionPortId) Reset()                    { *m = RteFlowActionPortId{} }
func (m *RteFlowActionPortId) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionPortId) ProtoMessage()               {}
func (*RteFlowActionPortId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *RteFlowActionPortId) GetOriginal() uint32 {
	if m != nil {
		return m.Original
	}
	return 0
}

func (m *RteFlowActionPortId) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *RteFlowActionPortId) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type RteFlowActionMeter struct {
	MtrId uint32 `protobuf:"varint,1,opt,name=mtr_id,json=mtrId" json:"mtr_id,omitempty"`
}

func (m *RteFlowActionMeter) Reset()                    { *m = RteFlowActionMeter{} }
func (m *RteFlowActionMeter) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionMeter) ProtoMessage()               {}
func (*RteFlowActionMeter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *RteFlowActionMeter) GetMtrId() uint32 {
	if m != nil {
		return m.MtrId
	}
	return 0
}

type RteFlowActionSecurity struct {
	SecuritySession *google_protobuf.Any `protobuf:"bytes,1,opt,name=security_session,json=securitySession" json:"security_session,omitempty"`
}

func (m *RteFlowActionSecurity) Reset()                    { *m = RteFlowActionSecurity{} }
func (m *RteFlowActionSecurity) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSecurity) ProtoMessage()               {}
func (*RteFlowActionSecurity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *RteFlowActionSecurity) GetSecuritySession() *google_protobuf.Any {
	if m != nil {
		return m.SecuritySession
	}
	return nil
}

type RteFlowActionOfSetMplsTtl struct {
	MplsTtl uint32 `protobuf:"varint,1,opt,name=mpls_ttl,json=mplsTtl" json:"mpls_ttl,omitempty"`
}

func (m *RteFlowActionOfSetMplsTtl) Reset()                    { *m = RteFlowActionOfSetMplsTtl{} }
func (m *RteFlowActionOfSetMplsTtl) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionOfSetMplsTtl) ProtoMessage()               {}
func (*RteFlowActionOfSetMplsTtl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

func (m *RteFlowActionOfSetMplsTtl) GetMplsTtl() uint32 {
	if m != nil {
		return m.MplsTtl
	}
	return 0
}

type RteFlowActionOfSetNwTtl struct {
	NwTtl uint32 `protobuf:"varint,1,opt,name=nw_ttl,json=nwTtl" json:"nw_ttl,omitempty"`
}

func (m *RteFlowActionOfSetNwTtl) Reset()                    { *m = RteFlowActionOfSetNwTtl{} }
func (m *RteFlowActionOfSetNwTtl) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionOfSetNwTtl) ProtoMessage()               {}
func (*RteFlowActionOfSetNwTtl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

func (m *RteFlowActionOfSetNwTtl) GetNwTtl() uint32 {
	if m != nil {
		return m.NwTtl
	}
	return 0
}

type RteFlowActionOfPushVlan struct {
	Ethertype uint32 `protobuf:"varint,1,opt,name=ethertype" json:"ethertype,omitempty"`
}

func (m *RteFlowActionOfPushVlan) Reset()                    { *m = RteFlowActionOfPushVlan{} }
func (m *RteFlowActionOfPushVlan) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionOfPushVlan) ProtoMessage()               {}
func (*RteFlowActionOfPushVlan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{70} }

func (m *RteFlowActionOfPushVlan) GetEthertype() uint32 {
	if m != nil {
		return m.Ethertype
	}
	return 0
}

type RteFlowActionOfSetVlanVid struct {
	VlanVid uint32 `protobuf:"varint,1,opt,name=vlan_vid,json=vlanVid" json:"vlan_vid,omitempty"`
}

func (m *RteFlowActionOfSetVlanVid) Reset()                    { *m = RteFlowActionOfSetVlanVid{} }
func (m *RteFlowActionOfSetVlanVid) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionOfSetVlanVid) ProtoMessage()               {}
func (*RteFlowActionOfSetVlanVid) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{71} }

func (m *RteFlowActionOfSetVlanVid) GetVlanVid() uint32 {
	if m != nil {
		return m.VlanVid
	}
	return 0
}

type RteFlowActionOfSetVlanPcp struct {
	VlanPcp uint32 `protobuf:"varint,1,opt,name=vlan_pcp,json=vlanPcp" json:"vlan_pcp,omitempty"`
}

func (m *RteFlowActionOfSetVlanPcp) Reset()                    { *m = RteFlowActionOfSetVlanPcp{} }
func (m *RteFlowActionOfSetVlanPcp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionOfSetVlanPcp) ProtoMessage()               {}
func (*RteFlowActionOfSetVlanPcp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72} }

func (m *RteFlowActionOfSetVlanPcp) GetVlanPcp() uint32 {
	if m != nil {
		return m.VlanPcp
	}
	return 0
}

type RteFlowActionOfPopMpls struct {
	Ethertype uint32 `protobuf:"varint,1,opt,name=ethertype" json:"ethertype,omitempty"`
}

func (m *RteFlowActionOfPopMpls) Reset()                    { *m = RteFlowActionOfPopMpls{} }
func (m *RteFlowActionOfPopMpls) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionOfPopMpls) ProtoMessage()               {}
func (*RteFlowActionOfPopMpls) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{73} }

func (m *RteFlowActionOfPopMpls) GetEthertype() uint32 {
	if m != nil {
		return m.Ethertype
	}
	return 0
}

type RteFlowActionOfPushMpls struct {
	Ethertype uint32 `protobuf:"varint,1,opt,name=ethertype" json:"ethertype,omitempty"`
}

func (m *RteFlowActionOfPushMpls) Reset()                    { *m = RteFlowActionOfPushMpls{} }
func (m *RteFlowActionOfPushMpls) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionOfPushMpls) ProtoMessage()               {}
func (*RteFlowActionOfPushMpls) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{74} }

func (m *RteFlowActionOfPushMpls) GetEthertype() uint32 {
	if m != nil {
		return m.Ethertype
	}
	return 0
}

type RteFlowActionVxlanEncap struct {
	// *
	// Encapsulating vxlan tunnel definition
	// (terminated by the END pattern item).
	Definition *RteFlowItem `protobuf:"bytes,1,opt,name=definition" json:"definition,omitempty"`
}

func (m *RteFlowActionVxlanEncap) Reset()                    { *m = RteFlowActionVxlanEncap{} }
func (m *RteFlowActionVxlanEncap) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionVxlanEncap) ProtoMessage()               {}
func (*RteFlowActionVxlanEncap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75} }

func (m *RteFlowActionVxlanEncap) GetDefinition() *RteFlowItem {
	if m != nil {
		return m.Definition
	}
	return nil
}

type RteFlowActionNvgreEncap struct {
	// *
	// Encapsulating vxlan tunnel definition
	// (terminated by the END pattern item).
	Definition *RteFlowItem `protobuf:"bytes,1,opt,name=definition" json:"definition,omitempty"`
}

func (m *RteFlowActionNvgreEncap) Reset()                    { *m = RteFlowActionNvgreEncap{} }
func (m *RteFlowActionNvgreEncap) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionNvgreEncap) ProtoMessage()               {}
func (*RteFlowActionNvgreEncap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{76} }

func (m *RteFlowActionNvgreEncap) GetDefinition() *RteFlowItem {
	if m != nil {
		return m.Definition
	}
	return nil
}

type RteFlowActionRawEncap struct {
	Data     uint32 `protobuf:"varint,1,opt,name=data" json:"data,omitempty"`
	Preserve uint32 `protobuf:"varint,2,opt,name=preserve" json:"preserve,omitempty"`
	Size     uint32 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
}

func (m *RteFlowActionRawEncap) Reset()                    { *m = RteFlowActionRawEncap{} }
func (m *RteFlowActionRawEncap) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionRawEncap) ProtoMessage()               {}
func (*RteFlowActionRawEncap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{77} }

func (m *RteFlowActionRawEncap) GetData() uint32 {
	if m != nil {
		return m.Data
	}
	return 0
}

func (m *RteFlowActionRawEncap) GetPreserve() uint32 {
	if m != nil {
		return m.Preserve
	}
	return 0
}

func (m *RteFlowActionRawEncap) GetSize() uint32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type RteFlowActionRawDecap struct {
	Data uint32 `protobuf:"varint,1,opt,name=data" json:"data,omitempty"`
	Size uint32 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
}

func (m *RteFlowActionRawDecap) Reset()                    { *m = RteFlowActionRawDecap{} }
func (m *RteFlowActionRawDecap) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionRawDecap) ProtoMessage()               {}
func (*RteFlowActionRawDecap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{78} }

func (m *RteFlowActionRawDecap) GetData() uint32 {
	if m != nil {
		return m.Data
	}
	return 0
}

func (m *RteFlowActionRawDecap) GetSize() uint32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type RteFlowActionSetIpv4 struct {
	Ipv4Addr uint32 `protobuf:"varint,1,opt,name=ipv4_addr,json=ipv4Addr" json:"ipv4_addr,omitempty"`
}

func (m *RteFlowActionSetIpv4) Reset()                    { *m = RteFlowActionSetIpv4{} }
func (m *RteFlowActionSetIpv4) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetIpv4) ProtoMessage()               {}
func (*RteFlowActionSetIpv4) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{79} }

func (m *RteFlowActionSetIpv4) GetIpv4Addr() uint32 {
	if m != nil {
		return m.Ipv4Addr
	}
	return 0
}

type RteFlowActionSetIpv6 struct {
	Ipv6Addr []uint32 `protobuf:"varint,1,rep,packed,name=ipv6_addr,json=ipv6Addr" json:"ipv6_addr,omitempty"`
}

func (m *RteFlowActionSetIpv6) Reset()                    { *m = RteFlowActionSetIpv6{} }
func (m *RteFlowActionSetIpv6) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetIpv6) ProtoMessage()               {}
func (*RteFlowActionSetIpv6) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{80} }

func (m *RteFlowActionSetIpv6) GetIpv6Addr() []uint32 {
	if m != nil {
		return m.Ipv6Addr
	}
	return nil
}

type RteFlowActionSetTp struct {
	Port uint32 `protobuf:"varint,1,opt,name=port" json:"port,omitempty"`
}

func (m *RteFlowActionSetTp) Reset()                    { *m = RteFlowActionSetTp{} }
func (m *RteFlowActionSetTp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetTp) ProtoMessage()               {}
func (*RteFlowActionSetTp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{81} }

func (m *RteFlowActionSetTp) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type RteFlowActionSetTtl struct {
	TtlValue uint32 `protobuf:"varint,1,opt,name=ttl_value,json=ttlValue" json:"ttl_value,omitempty"`
}

func (m *RteFlowActionSetTtl) Reset()                    { *m = RteFlowActionSetTtl{} }
func (m *RteFlowActionSetTtl) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetTtl) ProtoMessage()               {}
func (*RteFlowActionSetTtl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{82} }

func (m *RteFlowActionSetTtl) GetTtlValue() uint32 {
	if m != nil {
		return m.TtlValue
	}
	return 0
}

type RteFlowActionSetMac struct {
	MacAddrf []uint32 `protobuf:"varint,1,rep,packed,name=mac_addrf,json=macAddrf" json:"mac_addrf,omitempty"`
}

func (m *RteFlowActionSetMac) Reset()                    { *m = RteFlowActionSetMac{} }
func (m *RteFlowActionSetMac) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetMac) ProtoMessage()               {}
func (*RteFlowActionSetMac) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{83} }

func (m *RteFlowActionSetMac) GetMacAddrf() []uint32 {
	if m != nil {
		return m.MacAddrf
	}
	return nil
}

type RteFlowActionSetTag struct {
	Data  uint32 `protobuf:"varint,1,opt,name=data" json:"data,omitempty"`
	Mask  uint32 `protobuf:"varint,2,opt,name=mask" json:"mask,omitempty"`
	Index uint32 `protobuf:"varint,3,opt,name=index" json:"index,omitempty"`
}

func (m *RteFlowActionSetTag) Reset()                    { *m = RteFlowActionSetTag{} }
func (m *RteFlowActionSetTag) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetTag) ProtoMessage()               {}
func (*RteFlowActionSetTag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{84} }

func (m *RteFlowActionSetTag) GetData() uint32 {
	if m != nil {
		return m.Data
	}
	return 0
}

func (m *RteFlowActionSetTag) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *RteFlowActionSetTag) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type RteFlowActionSetMeta struct {
	Data uint32 `protobuf:"varint,1,opt,name=data" json:"data,omitempty"`
	Mask uint32 `protobuf:"varint,2,opt,name=mask" json:"mask,omitempty"`
}

func (m *RteFlowActionSetMeta) Reset()                    { *m = RteFlowActionSetMeta{} }
func (m *RteFlowActionSetMeta) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetMeta) ProtoMessage()               {}
func (*RteFlowActionSetMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{85} }

func (m *RteFlowActionSetMeta) GetData() uint32 {
	if m != nil {
		return m.Data
	}
	return 0
}

func (m *RteFlowActionSetMeta) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

type RteFlowActionSetDscp struct {
	Dscp uint32 `protobuf:"varint,1,opt,name=dscp" json:"dscp,omitempty"`
}

func (m *RteFlowActionSetDscp) Reset()                    { *m = RteFlowActionSetDscp{} }
func (m *RteFlowActionSetDscp) String() string            { return proto.CompactTextString(m) }
func (*RteFlowActionSetDscp) ProtoMessage()               {}
func (*RteFlowActionSetDscp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{86} }

func (m *RteFlowActionSetDscp) GetDscp() uint32 {
	if m != nil {
		return m.Dscp
	}
	return 0
}

type RteFlowAction struct {
	Type RteFlowActionType    `protobuf:"varint,1,opt,name=type,enum=flow.RteFlowActionType" json:"type,omitempty"`
	Conf *google_protobuf.Any `protobuf:"bytes,2,opt,name=conf" json:"conf,omitempty"`
}

func (m *RteFlowAction) Reset()                    { *m = RteFlowAction{} }
func (m *RteFlowAction) String() string            { return proto.CompactTextString(m) }
func (*RteFlowAction) ProtoMessage()               {}
func (*RteFlowAction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{87} }

func (m *RteFlowAction) GetType() RteFlowActionType {
	if m != nil {
		return m.Type
	}
	return RteFlowActionType_RTE_FLOW_ACTION_TYPE_END
}

func (m *RteFlowAction) GetConf() *google_protobuf.Any {
	if m != nil {
		return m.Conf
	}
	return nil
}

type RteFlowError struct {
	Type  RteFlowErrorType     `protobuf:"varint,1,opt,name=type,enum=flow.RteFlowErrorType" json:"type,omitempty"`
	Cause *google_protobuf.Any `protobuf:"bytes,2,opt,name=cause" json:"cause,omitempty"`
	Mesg  string               `protobuf:"bytes,3,opt,name=mesg" json:"mesg,omitempty"`
}

func (m *RteFlowError) Reset()                    { *m = RteFlowError{} }
func (m *RteFlowError) String() string            { return proto.CompactTextString(m) }
func (*RteFlowError) ProtoMessage()               {}
func (*RteFlowError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{88} }

func (m *RteFlowError) GetType() RteFlowErrorType {
	if m != nil {
		return m.Type
	}
	return RteFlowErrorType_RTE_FLOW_ERROR_TYPE_NONE
}

func (m *RteFlowError) GetCause() *google_protobuf.Any {
	if m != nil {
		return m.Cause
	}
	return nil
}

func (m *RteFlowError) GetMesg() string {
	if m != nil {
		return m.Mesg
	}
	return ""
}

type RteFlowListResult struct {
	FlowId      uint32 `protobuf:"varint,1,opt,name=flow_id,json=flowId" json:"flow_id,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *RteFlowListResult) Reset()                    { *m = RteFlowListResult{} }
func (m *RteFlowListResult) String() string            { return proto.CompactTextString(m) }
func (*RteFlowListResult) ProtoMessage()               {}
func (*RteFlowListResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{89} }

func (m *RteFlowListResult) GetFlowId() uint32 {
	if m != nil {
		return m.FlowId
	}
	return 0
}

func (m *RteFlowListResult) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// request of create and validate
type RequestFlowCreate struct {
	PortId  uint32           `protobuf:"varint,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	Attr    *RteFlowAttr     `protobuf:"bytes,2,opt,name=attr" json:"attr,omitempty"`
	Pattern []*RteFlowItem   `protobuf:"bytes,3,rep,name=pattern" json:"pattern,omitempty"`
	Action  []*RteFlowAction `protobuf:"bytes,4,rep,name=action" json:"action,omitempty"`
}

func (m *RequestFlowCreate) Reset()                    { *m = RequestFlowCreate{} }
func (m *RequestFlowCreate) String() string            { return proto.CompactTextString(m) }
func (*RequestFlowCreate) ProtoMessage()               {}
func (*RequestFlowCreate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{90} }

func (m *RequestFlowCreate) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *RequestFlowCreate) GetAttr() *RteFlowAttr {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *RequestFlowCreate) GetPattern() []*RteFlowItem {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *RequestFlowCreate) GetAction() []*RteFlowAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// request of query and destroy
type RequestFlowofPort struct {
	PortId uint32 `protobuf:"varint,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	FlowId uint32 `protobuf:"varint,2,opt,name=flow_id,json=flowId" json:"flow_id,omitempty"`
}

func (m *RequestFlowofPort) Reset()                    { *m = RequestFlowofPort{} }
func (m *RequestFlowofPort) String() string            { return proto.CompactTextString(m) }
func (*RequestFlowofPort) ProtoMessage()               {}
func (*RequestFlowofPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{91} }

func (m *RequestFlowofPort) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *RequestFlowofPort) GetFlowId() uint32 {
	if m != nil {
		return m.FlowId
	}
	return 0
}

// request of list and flush
type RequestofPort struct {
	PortId uint32 `protobuf:"varint,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
}

func (m *RequestofPort) Reset()                    { *m = RequestofPort{} }
func (m *RequestofPort) String() string            { return proto.CompactTextString(m) }
func (*RequestofPort) ProtoMessage()               {}
func (*RequestofPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{92} }

func (m *RequestofPort) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

// request of isolate
type RequestIsolate struct {
	PortId       uint32 `protobuf:"varint,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	IsolatedMode uint32 `protobuf:"varint,2,opt,name=isolated_mode,json=isolatedMode" json:"isolated_mode,omitempty"`
}

func (m *RequestIsolate) Reset()                    { *m = RequestIsolate{} }
func (m *RequestIsolate) String() string            { return proto.CompactTextString(m) }
func (*RequestIsolate) ProtoMessage()               {}
func (*RequestIsolate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{93} }

func (m *RequestIsolate) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *RequestIsolate) GetIsolatedMode() uint32 {
	if m != nil {
		return m.IsolatedMode
	}
	return 0
}

type RequestListPorts struct {
}

func (m *RequestListPorts) Reset()                    { *m = RequestListPorts{} }
func (m *RequestListPorts) String() string            { return proto.CompactTextString(m) }
func (*RequestListPorts) ProtoMessage()               {}
func (*RequestListPorts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{94} }

type PortsInformation struct {
	PortId   uint32 `protobuf:"varint,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	PortPci  string `protobuf:"bytes,2,opt,name=port_pci,json=portPci" json:"port_pci,omitempty"`
	PortMode string `protobuf:"bytes,3,opt,name=port_mode,json=portMode" json:"port_mode,omitempty"`
}

func (m *PortsInformation) Reset()                    { *m = PortsInformation{} }
func (m *PortsInformation) String() string            { return proto.CompactTextString(m) }
func (*PortsInformation) ProtoMessage()               {}
func (*PortsInformation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{95} }

func (m *PortsInformation) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *PortsInformation) GetPortPci() string {
	if m != nil {
		return m.PortPci
	}
	return ""
}

func (m *PortsInformation) GetPortMode() string {
	if m != nil {
		return m.PortMode
	}
	return ""
}

type ResponseFlow struct {
	ErrorInfo *RteFlowError `protobuf:"bytes,1,opt,name=error_info,json=errorInfo" json:"error_info,omitempty"`
}

func (m *ResponseFlow) Reset()                    { *m = ResponseFlow{} }
func (m *ResponseFlow) String() string            { return proto.CompactTextString(m) }
func (*ResponseFlow) ProtoMessage()               {}
func (*ResponseFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{96} }

func (m *ResponseFlow) GetErrorInfo() *RteFlowError {
	if m != nil {
		return m.ErrorInfo
	}
	return nil
}

type ResponseFlowCreate struct {
	FlowId    uint32        `protobuf:"varint,1,opt,name=flow_id,json=flowId" json:"flow_id,omitempty"`
	ErrorInfo *RteFlowError `protobuf:"bytes,2,opt,name=error_info,json=errorInfo" json:"error_info,omitempty"`
}

func (m *ResponseFlowCreate) Reset()                    { *m = ResponseFlowCreate{} }
func (m *ResponseFlowCreate) String() string            { return proto.CompactTextString(m) }
func (*ResponseFlowCreate) ProtoMessage()               {}
func (*ResponseFlowCreate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{97} }

func (m *ResponseFlowCreate) GetFlowId() uint32 {
	if m != nil {
		return m.FlowId
	}
	return 0
}

func (m *ResponseFlowCreate) GetErrorInfo() *RteFlowError {
	if m != nil {
		return m.ErrorInfo
	}
	return nil
}

type ResponseFlowQuery struct {
	ErrorInfo *RteFlowError      `protobuf:"bytes,1,opt,name=error_info,json=errorInfo" json:"error_info,omitempty"`
	Data      *RteFlowQueryCount `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
}

func (m *ResponseFlowQuery) Reset()                    { *m = ResponseFlowQuery{} }
func (m *ResponseFlowQuery) String() string            { return proto.CompactTextString(m) }
func (*ResponseFlowQuery) ProtoMessage()               {}
func (*ResponseFlowQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{98} }

func (m *ResponseFlowQuery) GetErrorInfo() *RteFlowError {
	if m != nil {
		return m.ErrorInfo
	}
	return nil
}

func (m *ResponseFlowQuery) GetData() *RteFlowQueryCount {
	if m != nil {
		return m.Data
	}
	return nil
}

type ResponseFlowList struct {
	Results []*RteFlowListResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *ResponseFlowList) Reset()                    { *m = ResponseFlowList{} }
func (m *ResponseFlowList) String() string            { return proto.CompactTextString(m) }
func (*ResponseFlowList) ProtoMessage()               {}
func (*ResponseFlowList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{99} }

func (m *ResponseFlowList) GetResults() []*RteFlowListResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type ResponsePortList struct {
	Ports []*PortsInformation `protobuf:"bytes,1,rep,name=ports" json:"ports,omitempty"`
}

func (m *ResponsePortList) Reset()                    { *m = ResponsePortList{} }
func (m *ResponsePortList) String() string            { return proto.CompactTextString(m) }
func (*ResponsePortList) ProtoMessage()               {}
func (*ResponsePortList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{100} }

func (m *ResponsePortList) GetPorts() []*PortsInformation {
	if m != nil {
		return m.Ports
	}
	return nil
}

func init() {
	proto.RegisterType((*RteFlowAttr)(nil), "flow.rte_flow_attr")
	proto.RegisterType((*GreKeyDefaultMask)(nil), "flow.gre_key_default_mask")
	proto.RegisterType((*RteFlowItemAny)(nil), "flow.rte_flow_item_any")
	proto.RegisterType((*RteFlowItemVf)(nil), "flow.rte_flow_item_vf")
	proto.RegisterType((*RteFlowItemPhyPort)(nil), "flow.rte_flow_item_phy_port")
	proto.RegisterType((*RteFlowItemPortId)(nil), "flow.rte_flow_item_port_id")
	proto.RegisterType((*RteFlowItemRaw)(nil), "flow.rte_flow_item_raw")
	proto.RegisterType((*RteEtherAddr)(nil), "flow.rte_ether_addr")
	proto.RegisterType((*RteFlowItemEth)(nil), "flow.rte_flow_item_eth")
	proto.RegisterType((*RteFlowItemVlan)(nil), "flow.rte_flow_item_vlan")
	proto.RegisterType((*RteIpv4Hdr)(nil), "flow.rte_ipv4_hdr")
	proto.RegisterType((*RteFlowItemIpv4)(nil), "flow.rte_flow_item_ipv4")
	proto.RegisterType((*RteIpv6Hdr)(nil), "flow.rte_ipv6_hdr")
	proto.RegisterType((*RteFlowItemIpv6)(nil), "flow.rte_flow_item_ipv6")
	proto.RegisterType((*RteIcmpHdr)(nil), "flow.rte_icmp_hdr")
	proto.RegisterType((*RteFlowItemIcmp)(nil), "flow.rte_flow_item_icmp")
	proto.RegisterType((*RteUdpHdr)(nil), "flow.rte_udp_hdr")
	proto.RegisterType((*RteFlowItemUdp)(nil), "flow.rte_flow_item_udp")
	proto.RegisterType((*RteTcpHdr)(nil), "flow.rte_tcp_hdr")
	proto.RegisterType((*RteFlowItemTcp)(nil), "flow.rte_flow_item_tcp")
	proto.RegisterType((*RteSctpHdr)(nil), "flow.rte_sctp_hdr")
	proto.RegisterType((*RteFlowItemSctp)(nil), "flow.rte_flow_item_sctp")
	proto.RegisterType((*RteFlowItemVxlan)(nil), "flow.rte_flow_item_vxlan")
	proto.RegisterType((*RteFlowItemETag)(nil), "flow.rte_flow_item_e_tag")
	proto.RegisterType((*RteFlowItemNvgre)(nil), "flow.rte_flow_item_nvgre")
	proto.RegisterType((*RteFlowItemMpls)(nil), "flow.rte_flow_item_mpls")
	proto.RegisterType((*RteFlowItemGre)(nil), "flow.rte_flow_item_gre")
	proto.RegisterType((*RteFlowItemFuzzy)(nil), "flow.rte_flow_item_fuzzy")
	proto.RegisterType((*RteFlowItemGtp)(nil), "flow.rte_flow_item_gtp")
	proto.RegisterType((*RteEspHdr)(nil), "flow.rte_esp_hdr")
	proto.RegisterType((*RteFlowItemEsp)(nil), "flow.rte_flow_item_esp")
	proto.RegisterType((*RteFlowItemGeneve)(nil), "flow.rte_flow_item_geneve")
	proto.RegisterType((*RteFlowItemVxlanGpe)(nil), "flow.rte_flow_item_vxlan_gpe")
	proto.RegisterType((*RteFlowItemArpEthIpv4)(nil), "flow.rte_flow_item_arp_eth_ipv4")
	proto.RegisterType((*RteFlowItemIpv6Ext)(nil), "flow.rte_flow_item_ipv6_ext")
	proto.RegisterType((*RteFlowItemIcmp6)(nil), "flow.rte_flow_item_icmp6")
	proto.RegisterType((*RteFlowItemIcmp6NdNs)(nil), "flow.rte_flow_item_icmp6_nd_ns")
	proto.RegisterType((*RteFlowItemIcmp6NdNa)(nil), "flow.rte_flow_item_icmp6_nd_na")
	proto.RegisterType((*RteFlowItemIcmp6NdOpt)(nil), "flow.rte_flow_item_icmp6_nd_opt")
	proto.RegisterType((*RteFlowItemIcmp6NdOptSlaEth)(nil), "flow.rte_flow_item_icmp6_nd_opt_sla_eth")
	proto.RegisterType((*RteFlowItemIcmp6NdOptStaEth)(nil), "flow.rte_flow_item_icmp6_nd_opt_sta_eth")
	proto.RegisterType((*RteFlowItemMark)(nil), "flow.rte_flow_item_mark")
	proto.RegisterType((*RteFlowItemMeta)(nil), "flow.rte_flow_item_meta")
	proto.RegisterType((*RteFlowItemGtpPsc)(nil), "flow.rte_flow_item_gtp_psc")
	proto.RegisterType((*RteFlowItemPppoe)(nil), "flow.rte_flow_item_pppoe")
	proto.RegisterType((*RteFlowItemPppoeProtoId)(nil), "flow.rte_flow_item_pppoe_proto_id")
	proto.RegisterType((*RteFlowItemNsh)(nil), "flow.rte_flow_item_nsh")
	proto.RegisterType((*RteFlowItemIgmp)(nil), "flow.rte_flow_item_igmp")
	proto.RegisterType((*RteFlowItemAh)(nil), "flow.rte_flow_item_ah")
	proto.RegisterType((*RteHigig2Frc)(nil), "flow.rte_higig2_frc")
	proto.RegisterType((*RteHigig2PptType0)(nil), "flow.rte_higig2_ppt_type0")
	proto.RegisterType((*RteHigig2PptType1)(nil), "flow.rte_higig2_ppt_type1")
	proto.RegisterType((*RteHigig2Hdr)(nil), "flow.rte_higig2_hdr")
	proto.RegisterType((*RteFlowItemHigig2Hdr)(nil), "flow.rte_flow_item_higig2_hdr")
	proto.RegisterType((*RteFlowItemTag)(nil), "flow.rte_flow_item_tag")
	proto.RegisterType((*RteFlowItemL2Tpv3Oip)(nil), "flow.rte_flow_item_l2tpv3oip")
	proto.RegisterType((*RteFlowItem)(nil), "flow.rte_flow_item")
	proto.RegisterType((*RteFlowActionMark)(nil), "flow.rte_flow_action_mark")
	proto.RegisterType((*RteFlowActionJump)(nil), "flow.rte_flow_action_jump")
	proto.RegisterType((*RteFlowActionQueue)(nil), "flow.rte_flow_action_queue")
	proto.RegisterType((*RteFlowActionCount)(nil), "flow.rte_flow_action_count")
	proto.RegisterType((*RteFlowQueryCount)(nil), "flow.rte_flow_query_count")
	proto.RegisterType((*RteFlowActionRss)(nil), "flow.rte_flow_action_rss")
	proto.RegisterType((*RteFlowActionVf)(nil), "flow.rte_flow_action_vf")
	proto.RegisterType((*RteFlowActionPhyPort)(nil), "flow.rte_flow_action_phy_port")
	proto.RegisterType((*RteFlowActionPortId)(nil), "flow.rte_flow_action_port_id")
	proto.RegisterType((*RteFlowActionMeter)(nil), "flow.rte_flow_action_meter")
	proto.RegisterType((*RteFlowActionSecurity)(nil), "flow.rte_flow_action_security")
	proto.RegisterType((*RteFlowActionOfSetMplsTtl)(nil), "flow.rte_flow_action_of_set_mpls_ttl")
	proto.RegisterType((*RteFlowActionOfSetNwTtl)(nil), "flow.rte_flow_action_of_set_nw_ttl")
	proto.RegisterType((*RteFlowActionOfPushVlan)(nil), "flow.rte_flow_action_of_push_vlan")
	proto.RegisterType((*RteFlowActionOfSetVlanVid)(nil), "flow.rte_flow_action_of_set_vlan_vid")
	proto.RegisterType((*RteFlowActionOfSetVlanPcp)(nil), "flow.rte_flow_action_of_set_vlan_pcp")
	proto.RegisterType((*RteFlowActionOfPopMpls)(nil), "flow.rte_flow_action_of_pop_mpls")
	proto.RegisterType((*RteFlowActionOfPushMpls)(nil), "flow.rte_flow_action_of_push_mpls")
	proto.RegisterType((*RteFlowActionVxlanEncap)(nil), "flow.rte_flow_action_vxlan_encap")
	proto.RegisterType((*RteFlowActionNvgreEncap)(nil), "flow.rte_flow_action_nvgre_encap")
	proto.RegisterType((*RteFlowActionRawEncap)(nil), "flow.rte_flow_action_raw_encap")
	proto.RegisterType((*RteFlowActionRawDecap)(nil), "flow.rte_flow_action_raw_decap")
	proto.RegisterType((*RteFlowActionSetIpv4)(nil), "flow.rte_flow_action_set_ipv4")
	proto.RegisterType((*RteFlowActionSetIpv6)(nil), "flow.rte_flow_action_set_ipv6")
	proto.RegisterType((*RteFlowActionSetTp)(nil), "flow.rte_flow_action_set_tp")
	proto.RegisterType((*RteFlowActionSetTtl)(nil), "flow.rte_flow_action_set_ttl")
	proto.RegisterType((*RteFlowActionSetMac)(nil), "flow.rte_flow_action_set_mac")
	proto.RegisterType((*RteFlowActionSetTag)(nil), "flow.rte_flow_action_set_tag")
	proto.RegisterType((*RteFlowActionSetMeta)(nil), "flow.rte_flow_action_set_meta")
	proto.RegisterType((*RteFlowActionSetDscp)(nil), "flow.rte_flow_action_set_dscp")
	proto.RegisterType((*RteFlowAction)(nil), "flow.rte_flow_action")
	proto.RegisterType((*RteFlowError)(nil), "flow.rte_flow_error")
	proto.RegisterType((*RteFlowListResult)(nil), "flow.rte_flow_list_result")
	proto.RegisterType((*RequestFlowCreate)(nil), "flow.RequestFlowCreate")
	proto.RegisterType((*RequestFlowofPort)(nil), "flow.RequestFlowofPort")
	proto.RegisterType((*RequestofPort)(nil), "flow.RequestofPort")
	proto.RegisterType((*RequestIsolate)(nil), "flow.RequestIsolate")
	proto.RegisterType((*RequestListPorts)(nil), "flow.RequestListPorts")
	proto.RegisterType((*PortsInformation)(nil), "flow.ports_information")
	proto.RegisterType((*ResponseFlow)(nil), "flow.ResponseFlow")
	proto.RegisterType((*ResponseFlowCreate)(nil), "flow.ResponseFlowCreate")
	proto.RegisterType((*ResponseFlowQuery)(nil), "flow.ResponseFlowQuery")
	proto.RegisterType((*ResponseFlowList)(nil), "flow.ResponseFlowList")
	proto.RegisterType((*ResponsePortList)(nil), "flow.ResponsePortList")
	proto.RegisterEnum("flow.RteFlowItemType", RteFlowItemType_name, RteFlowItemType_value)
	proto.RegisterEnum("flow.RteEthHashFunction", RteEthHashFunction_name, RteEthHashFunction_value)
	proto.RegisterEnum("flow.RteFlowActionType", RteFlowActionType_name, RteFlowActionType_value)
	proto.RegisterEnum("flow.RteFlowErrorType", RteFlowErrorType_name, RteFlowErrorType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FlowService service

type FlowServiceClient interface {
	Validate(ctx context.Context, in *RequestFlowCreate, opts ...grpc.CallOption) (*ResponseFlow, error)
	Create(ctx context.Context, in *RequestFlowCreate, opts ...grpc.CallOption) (*ResponseFlowCreate, error)
	Destroy(ctx context.Context, in *RequestFlowofPort, opts ...grpc.CallOption) (*ResponseFlow, error)
	Query(ctx context.Context, in *RequestFlowofPort, opts ...grpc.CallOption) (*ResponseFlowQuery, error)
	List(ctx context.Context, in *RequestofPort, opts ...grpc.CallOption) (*ResponseFlowList, error)
	Flush(ctx context.Context, in *RequestofPort, opts ...grpc.CallOption) (*ResponseFlow, error)
	Isolate(ctx context.Context, in *RequestIsolate, opts ...grpc.CallOption) (*ResponseFlow, error)
	ListPorts(ctx context.Context, in *RequestListPorts, opts ...grpc.CallOption) (*ResponsePortList, error)
}

type flowServiceClient struct {
	cc *grpc.ClientConn
}

func NewFlowServiceClient(cc *grpc.ClientConn) FlowServiceClient {
	return &flowServiceClient{cc}
}

func (c *flowServiceClient) Validate(ctx context.Context, in *RequestFlowCreate, opts ...grpc.CallOption) (*ResponseFlow, error) {
	out := new(ResponseFlow)
	err := grpc.Invoke(ctx, "/flow.FlowService/Validate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowServiceClient) Create(ctx context.Context, in *RequestFlowCreate, opts ...grpc.CallOption) (*ResponseFlowCreate, error) {
	out := new(ResponseFlowCreate)
	err := grpc.Invoke(ctx, "/flow.FlowService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowServiceClient) Destroy(ctx context.Context, in *RequestFlowofPort, opts ...grpc.CallOption) (*ResponseFlow, error) {
	out := new(ResponseFlow)
	err := grpc.Invoke(ctx, "/flow.FlowService/Destroy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowServiceClient) Query(ctx context.Context, in *RequestFlowofPort, opts ...grpc.CallOption) (*ResponseFlowQuery, error) {
	out := new(ResponseFlowQuery)
	err := grpc.Invoke(ctx, "/flow.FlowService/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowServiceClient) List(ctx context.Context, in *RequestofPort, opts ...grpc.CallOption) (*ResponseFlowList, error) {
	out := new(ResponseFlowList)
	err := grpc.Invoke(ctx, "/flow.FlowService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowServiceClient) Flush(ctx context.Context, in *RequestofPort, opts ...grpc.CallOption) (*ResponseFlow, error) {
	out := new(ResponseFlow)
	err := grpc.Invoke(ctx, "/flow.FlowService/Flush", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowServiceClient) Isolate(ctx context.Context, in *RequestIsolate, opts ...grpc.CallOption) (*ResponseFlow, error) {
	out := new(ResponseFlow)
	err := grpc.Invoke(ctx, "/flow.FlowService/Isolate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowServiceClient) ListPorts(ctx context.Context, in *RequestListPorts, opts ...grpc.CallOption) (*ResponsePortList, error) {
	out := new(ResponsePortList)
	err := grpc.Invoke(ctx, "/flow.FlowService/ListPorts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FlowService service

type FlowServiceServer interface {
	Validate(context.Context, *RequestFlowCreate) (*ResponseFlow, error)
	Create(context.Context, *RequestFlowCreate) (*ResponseFlowCreate, error)
	Destroy(context.Context, *RequestFlowofPort) (*ResponseFlow, error)
	Query(context.Context, *RequestFlowofPort) (*ResponseFlowQuery, error)
	List(context.Context, *RequestofPort) (*ResponseFlowList, error)
	Flush(context.Context, *RequestofPort) (*ResponseFlow, error)
	Isolate(context.Context, *RequestIsolate) (*ResponseFlow, error)
	ListPorts(context.Context, *RequestListPorts) (*ResponsePortList, error)
}

func RegisterFlowServiceServer(s *grpc.Server, srv FlowServiceServer) {
	s.RegisterService(&_FlowService_serviceDesc, srv)
}

func _FlowService_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFlowCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/Validate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).Validate(ctx, req.(*RequestFlowCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFlowCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).Create(ctx, req.(*RequestFlowCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowService_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFlowofPort)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).Destroy(ctx, req.(*RequestFlowofPort))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFlowofPort)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).Query(ctx, req.(*RequestFlowofPort))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestofPort)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).List(ctx, req.(*RequestofPort))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowService_Flush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestofPort)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).Flush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/Flush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).Flush(ctx, req.(*RequestofPort))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowService_Isolate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestIsolate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).Isolate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/Isolate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).Isolate(ctx, req.(*RequestIsolate))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowService_ListPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestListPorts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServiceServer).ListPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/flow.FlowService/ListPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServiceServer).ListPorts(ctx, req.(*RequestListPorts))
	}
	return interceptor(ctx, in, info, handler)
}

var _FlowService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "flow.FlowService",
	HandlerType: (*FlowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Validate",
			Handler:    _FlowService_Validate_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _FlowService_Create_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _FlowService_Destroy_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _FlowService_Query_Handler,
		},
		{
			MethodName: "List",
			Handler:    _FlowService_List_Handler,
		},
		{
			MethodName: "Flush",
			Handler:    _FlowService_Flush_Handler,
		},
		{
			MethodName: "Isolate",
			Handler:    _FlowService_Isolate_Handler,
		},
		{
			MethodName: "ListPorts",
			Handler:    _FlowService_ListPorts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "flow.proto",
}

func init() { proto.RegisterFile("flow.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 4944 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5b, 0xcd, 0x6f, 0xe3, 0x4a,
	0x72, 0x1f, 0xd9, 0xf2, 0x57, 0xfb, 0x63, 0x7a, 0x38, 0x5f, 0xb2, 0xe7, 0x9b, 0xf3, 0xb9, 0xb3,
	0xf3, 0x65, 0xcf, 0x5b, 0xe7, 0x6d, 0x76, 0x17, 0x81, 0x9e, 0x2c, 0xdb, 0xca, 0xd8, 0x12, 0x1f,
	0x45, 0xcf, 0xbc, 0x79, 0x1b, 0xa0, 0xc1, 0x21, 0x5b, 0x12, 0x63, 0x8a, 0xa4, 0xc9, 0x96, 0x6c,
	0xbf, 0x4b, 0xbe, 0x0e, 0x41, 0xb0, 0xe7, 0x00, 0x39, 0x24, 0x40, 0x80, 0x00, 0x39, 0x24, 0xc7,
	0x20, 0xa7, 0xe4, 0x96, 0x73, 0x80, 0xe4, 0x2f, 0xd8, 0x53, 0x80, 0xdc, 0x72, 0xcc, 0x29, 0x40,
	0x50, 0xfd, 0x21, 0x51, 0x94, 0x28, 0xcf, 0xbe, 0xb7, 0x27, 0xb3, 0xbb, 0x7e, 0x5d, 0x5d, 0x5d,
	0x55, 0xdd, 0x5d, 0x55, 0x2d, 0x23, 0xd4, 0xf2, 0xc3, 0xd3, 0x57, 0x51, 0x1c, 0xb2, 0x50, 0x2b,
	0xc2, 0xf7, 0xc6, 0x7a, 0x3b, 0x0c, 0xdb, 0x3e, 0x7d, 0xcd, 0xfb, 0x3e, 0xf5, 0x5a, 0xaf, 0xed,
	0xe0, 0x5c, 0x00, 0xf4, 0x7f, 0x2c, 0xa0, 0xd5, 0x98, 0x51, 0x02, 0x38, 0x62, 0x33, 0x16, 0x6b,
	0xd7, 0xd0, 0x5c, 0x3b, 0x0e, 0x7b, 0x51, 0xa9, 0x70, 0xbf, 0xf0, 0x6c, 0xd5, 0x14, 0x0d, 0x6d,
	0x03, 0x2d, 0x46, 0xb1, 0x17, 0xc6, 0x1e, 0x3b, 0x2f, 0xcd, 0x70, 0xc2, 0xa0, 0xad, 0x95, 0xd0,
	0x82, 0x17, 0xb4, 0x63, 0x9a, 0x24, 0xa5, 0x59, 0x4e, 0x52, 0x4d, 0xed, 0x06, 0x9a, 0xa7, 0x82,
	0x50, 0xe4, 0x04, 0xd9, 0x02, 0x6e, 0x2c, 0xb6, 0x83, 0xa4, 0x45, 0xe3, 0xd2, 0x9c, 0xe0, 0xa6,
	0xda, 0x40, 0x8b, 0x69, 0x42, 0xe3, 0x3e, 0x75, 0x4b, 0xf3, 0x82, 0xa6, 0xda, 0xfa, 0x1e, 0xba,
	0xd6, 0x8e, 0x29, 0x39, 0xa6, 0xe7, 0xc4, 0xa5, 0x2d, 0xbb, 0xe7, 0x33, 0xd2, 0xb5, 0x93, 0x63,
	0xed, 0xf5, 0xe4, 0x7e, 0xb9, 0x84, 0x2b, 0xed, 0x98, 0xbe, 0xa3, 0xe7, 0x3b, 0x82, 0x72, 0x68,
	0x27, 0xc7, 0xfa, 0x63, 0x74, 0x65, 0xb0, 0x6a, 0x8f, 0xd1, 0x2e, 0xb1, 0x83, 0x73, 0x0d, 0xa3,
	0xd9, 0xa0, 0xd7, 0x95, 0x83, 0xe0, 0x53, 0xd7, 0x11, 0x1e, 0x85, 0xf5, 0x5b, 0xda, 0x1a, 0x9a,
	0xf1, 0x5c, 0x09, 0x9a, 0xf1, 0x5c, 0xfd, 0x15, 0xba, 0x31, 0x8a, 0x89, 0x3a, 0xe7, 0x24, 0x0a,
	0x63, 0x06, 0x9a, 0xf4, 0x02, 0x97, 0x9e, 0x29, 0x4d, 0xf2, 0x86, 0xfe, 0x14, 0x5d, 0xcf, 0xe0,
	0xc3, 0x98, 0x11, 0xcf, 0x1d, 0x63, 0xfc, 0x6f, 0x85, 0xac, 0x90, 0xb1, 0x7d, 0x2a, 0xd4, 0xe3,
	0xdb, 0xcc, 0xeb, 0x53, 0x89, 0x1d, 0xb4, 0x41, 0xdd, 0x09, 0xb5, 0x63, 0xa7, 0x23, 0x4d, 0x24,
	0x5b, 0x23, 0x2a, 0x9d, 0x1d, 0x55, 0x29, 0x8c, 0x09, 0x5b, 0xad, 0x84, 0x32, 0x6e, 0xa2, 0x39,
	0x53, 0xb6, 0x40, 0x78, 0xdf, 0xeb, 0x7a, 0x4c, 0xda, 0x47, 0x34, 0x00, 0xed, 0xd3, 0xa0, 0xcd,
	0x3a, 0xd2, 0x34, 0xb2, 0x05, 0x2e, 0x10, 0xd9, 0x8c, 0xd1, 0x38, 0x28, 0x2d, 0x08, 0x17, 0x90,
	0x4d, 0xfd, 0x35, 0x5a, 0x83, 0x45, 0x50, 0xd6, 0xa1, 0x31, 0xb1, 0x5d, 0x37, 0xd6, 0xee, 0x20,
	0x04, 0x7f, 0xc9, 0xa7, 0x73, 0x46, 0x13, 0xbe, 0x86, 0x15, 0x73, 0x09, 0x7a, 0xbe, 0x82, 0x0e,
	0xfd, 0x34, 0xbb, 0x6a, 0xca, 0x3a, 0xda, 0x13, 0x34, 0xeb, 0x26, 0x8c, 0x83, 0x97, 0xb7, 0xae,
	0xbd, 0xe2, 0x1e, 0x3e, 0xca, 0xd6, 0x04, 0x00, 0xe0, 0x92, 0xd8, 0xe1, 0xcb, 0xcf, 0xc5, 0x25,
	0xb1, 0xa3, 0x69, 0xa8, 0xc8, 0xce, 0x23, 0x2a, 0xb5, 0xc1, 0xbf, 0xf5, 0x2a, 0xd2, 0x32, 0xc6,
	0xf6, 0xed, 0x00, 0x9c, 0x82, 0x39, 0x9e, 0x72, 0x0a, 0xe6, 0x78, 0x20, 0xbf, 0x17, 0x04, 0x34,
	0x26, 0x9c, 0x83, 0xd0, 0xf4, 0x12, 0xef, 0xb1, 0x80, 0xcd, 0xaf, 0x67, 0xd0, 0x0a, 0xf0, 0xf1,
	0xa2, 0xfe, 0x17, 0xa4, 0xe3, 0xc6, 0xda, 0x3d, 0xb4, 0xdc, 0xa7, 0x71, 0xe2, 0x85, 0x01, 0xf1,
	0x3a, 0xbe, 0xe4, 0x84, 0x64, 0x57, 0xad, 0xe3, 0x6b, 0x4f, 0xd0, 0x65, 0x60, 0x45, 0xc2, 0x16,
	0x01, 0xa3, 0x78, 0x8e, 0xe2, 0xba, 0x0a, 0xdd, 0x8d, 0x56, 0x53, 0x74, 0x6a, 0x0f, 0xd0, 0x0a,
	0x0b, 0x99, 0xed, 0x13, 0x69, 0x02, 0x21, 0xfc, 0x32, 0xef, 0x3b, 0x10, 0x76, 0xb8, 0x85, 0x96,
	0x22, 0xdb, 0x39, 0xa6, 0xe0, 0x50, 0x72, 0xcf, 0x2d, 0x8a, 0x8e, 0x9a, 0xab, 0x3d, 0x45, 0x97,
	0x5b, 0xb1, 0xdd, 0xee, 0xd2, 0x80, 0x11, 0x69, 0x73, 0x61, 0xdc, 0x35, 0xd5, 0xdd, 0x10, 0xb6,
	0xbf, 0x8f, 0x56, 0x98, 0xd7, 0xa5, 0x84, 0x85, 0xc4, 0x07, 0x3f, 0x13, 0xb6, 0x46, 0xd0, 0x67,
	0x85, 0x07, 0xe0, 0x69, 0x3a, 0x5a, 0x0d, 0xe8, 0x19, 0x23, 0xfc, 0x10, 0x81, 0xb9, 0x84, 0xd5,
	0x97, 0xa1, 0xd3, 0x80, 0xbe, 0x9a, 0x0b, 0xe2, 0x76, 0xdc, 0x98, 0x38, 0x1d, 0xea, 0x1c, 0x27,
	0xbd, 0x6e, 0x69, 0x51, 0x40, 0x3a, 0x6e, 0x5c, 0x91, 0x5d, 0xda, 0x3a, 0x5a, 0x4c, 0x62, 0x87,
	0xdb, 0xa5, 0xb4, 0x24, 0xfc, 0x26, 0x89, 0x9d, 0x32, 0x78, 0xc9, 0x3a, 0x5a, 0x74, 0x13, 0x26,
	0x48, 0x48, 0x90, 0xdc, 0x84, 0x01, 0x49, 0xff, 0xdd, 0xac, 0xa1, 0x40, 0xd5, 0xda, 0x23, 0x34,
	0xdb, 0x71, 0x63, 0xe9, 0x22, 0xda, 0xd0, 0xf4, 0xca, 0x0e, 0x26, 0x90, 0xf5, 0x7f, 0x2e, 0x0c,
	0xac, 0xb3, 0xcd, 0xad, 0xb3, 0x8e, 0x16, 0xfb, 0xcc, 0xe1, 0xcc, 0xa4, 0x69, 0x16, 0xfa, 0xcc,
	0xd9, 0xf5, 0xc3, 0x53, 0x30, 0x5c, 0x64, 0x9f, 0xfb, 0xa1, 0xed, 0x82, 0xc6, 0xa5, 0x4d, 0x90,
	0xec, 0x3a, 0xa0, 0x01, 0xec, 0x11, 0xae, 0x00, 0x69, 0x09, 0xd1, 0x00, 0xff, 0xe8, 0x84, 0x11,
	0xe1, 0x1b, 0x46, 0x1d, 0x7c, 0x4b, 0x9d, 0x30, 0x3a, 0xe0, 0x1d, 0x23, 0x6b, 0x9e, 0xe3, 0xce,
	0x3f, 0x71, 0xcd, 0xf3, 0x82, 0x34, 0x6d, 0xcd, 0xdb, 0xd3, 0xd6, 0xbc, 0x3d, 0x5c, 0xf3, 0xdf,
	0xab, 0x35, 0x3b, 0xdd, 0x88, 0xaf, 0xf9, 0x16, 0x5a, 0xe2, 0xdf, 0xdc, 0x81, 0xe5, 0x21, 0x02,
	0x1d, 0xe0, 0xbf, 0x03, 0xa2, 0x13, 0xba, 0xca, 0x0f, 0x39, 0xb1, 0x12, 0xba, 0x94, 0xfb, 0x3e,
	0x27, 0x72, 0x8b, 0xce, 0x4a, 0xdf, 0x07, 0x2a, 0xb7, 0xa7, 0x22, 0x7b, 0x2e, 0x0d, 0x98, 0x5a,
	0x3a, 0xf4, 0xd4, 0xa0, 0x43, 0xbb, 0x8b, 0x96, 0x39, 0x39, 0xa1, 0x27, 0x24, 0xf8, 0x24, 0x9d,
	0x8f, 0xd3, 0x9b, 0xf4, 0xa4, 0xfe, 0x69, 0xc2, 0x22, 0x9d, 0x6e, 0x94, 0xbf, 0x48, 0xb9, 0x1c,
	0xb1, 0xc8, 0x3f, 0x29, 0xa0, 0x65, 0xe8, 0xed, 0xb9, 0x91, 0xb2, 0x2b, 0xa8, 0x19, 0x0e, 0x57,
	0x65, 0xd7, 0x24, 0x76, 0x0c, 0x38, 0x97, 0xa5, 0x9a, 0x39, 0x69, 0x66, 0xe0, 0x5a, 0x9c, 0x74,
	0x0b, 0x2d, 0xb9, 0xed, 0xd8, 0xee, 0x72, 0x83, 0xcb, 0xa3, 0x92, 0x77, 0x80, 0xb9, 0xef, 0xa1,
	0x65, 0x41, 0x14, 0xab, 0x17, 0xcb, 0x43, 0xbc, 0x8b, 0x2f, 0x5f, 0xff, 0x32, 0x7b, 0x74, 0xf5,
	0xdc, 0x48, 0x7b, 0x98, 0x16, 0xff, 0xca, 0x50, 0x7c, 0x29, 0xa8, 0x90, 0xfe, 0x7f, 0xa5, 0xf4,
	0xcc, 0xf9, 0x21, 0xd2, 0xc3, 0x28, 0xd8, 0xdc, 0x09, 0x3d, 0x51, 0x37, 0x31, 0xb4, 0x9b, 0xf4,
	0x04, 0x48, 0x31, 0x75, 0xfa, 0xc4, 0x76, 0x8e, 0xa5, 0xe0, 0x0b, 0xd0, 0x2e, 0x3b, 0xc7, 0x9c,
	0xa1, 0xcd, 0x6c, 0x38, 0x12, 0xa4, 0x49, 0x16, 0xa0, 0xdd, 0x68, 0xb5, 0x40, 0x1d, 0x20, 0x51,
	0xcb, 0xb7, 0xdb, 0x89, 0xba, 0x8c, 0x99, 0x13, 0xed, 0x42, 0x5b, 0xbb, 0x8e, 0xe6, 0xe3, 0x33,
	0x72, 0xea, 0xa9, 0x23, 0x7f, 0x2e, 0x3e, 0xfb, 0xe0, 0xf1, 0x4d, 0x91, 0xde, 0xef, 0xa2, 0xa1,
	0xdd, 0x44, 0x0b, 0xc0, 0xa9, 0x17, 0x47, 0x72, 0xa3, 0xcf, 0x33, 0x27, 0x3a, 0x8a, 0xa3, 0x71,
	0x9d, 0x31, 0x27, 0x5f, 0x67, 0x52, 0x3d, 0x42, 0x67, 0xbe, 0xf0, 0xea, 0xc4, 0x61, 0x3f, 0x44,
	0x67, 0x70, 0xbe, 0xdb, 0x6d, 0xa9, 0x2e, 0xf8, 0x1c, 0x2e, 0xa0, 0x98, 0x5a, 0xc0, 0xb8, 0x6f,
	0xc2, 0xbc, 0xb9, 0xbe, 0xa9, 0x84, 0x12, 0x92, 0x7a, 0xe8, 0x6a, 0xe6, 0x66, 0x39, 0x83, 0xab,
	0xe5, 0x1a, 0x9a, 0x13, 0x9a, 0x95, 0xf1, 0x01, 0x6f, 0x40, 0x6f, 0x9c, 0xf4, 0xdd, 0x37, 0x5c,
	0xd0, 0x15, 0x53, 0x34, 0x40, 0xcc, 0x7e, 0xe0, 0x71, 0x31, 0x57, 0x4c, 0xf8, 0x54, 0xb8, 0x4d,
	0x25, 0x26, 0x6f, 0xe8, 0xff, 0x5a, 0xc8, 0xce, 0x45, 0x09, 0x2c, 0xea, 0x05, 0xba, 0x4a, 0x23,
	0x27, 0x22, 0xd4, 0xa5, 0x1e, 0xf1, 0x02, 0x42, 0x1d, 0xcf, 0x25, 0x9f, 0xe4, 0xcc, 0x97, 0x81,
	0x54, 0x75, 0xa9, 0x57, 0x0b, 0xaa, 0x8e, 0xe7, 0x7e, 0xa5, 0x3d, 0x46, 0x97, 0x81, 0x1d, 0x69,
	0xc7, 0x91, 0x42, 0x0a, 0xb5, 0xad, 0x40, 0xf7, 0x5e, 0x1c, 0x09, 0xd8, 0x06, 0x5a, 0x52, 0xac,
	0xe8, 0x30, 0xf4, 0x03, 0x5a, 0x15, 0xbc, 0x43, 0x12, 0xa4, 0x7c, 0x94, 0x77, 0x8f, 0x5e, 0x9e,
	0x73, 0xd9, 0xcb, 0xf3, 0x4f, 0xc7, 0xc4, 0x0f, 0xfa, 0xed, 0x98, 0x6a, 0x8f, 0xd0, 0x65, 0x87,
	0x1c, 0x93, 0x84, 0x70, 0x6d, 0x90, 0x3e, 0x8d, 0xa5, 0xe8, 0xcb, 0xce, 0xbb, 0xa6, 0x09, 0x7d,
	0xef, 0x45, 0xe8, 0xc8, 0x8f, 0x60, 0x27, 0xf4, 0x87, 0x41, 0xaa, 0x68, 0x73, 0x3b, 0x0f, 0x15,
	0xc8, 0x02, 0x0f, 0x5c, 0x52, 0x4c, 0xa3, 0x6e, 0xca, 0x79, 0x68, 0xd6, 0x5c, 0x7d, 0x27, 0x6b,
	0xea, 0x6e, 0xe4, 0x27, 0xda, 0x6d, 0x84, 0x7c, 0xfb, 0x13, 0xf5, 0x09, 0x73, 0x88, 0x0a, 0x5b,
	0x16, 0x79, 0x8f, 0xe5, 0x34, 0x39, 0x7b, 0xa6, 0x66, 0x85, 0x4f, 0xbd, 0x91, 0x75, 0x6c, 0x58,
	0xc7, 0x5d, 0xb4, 0xec, 0x8c, 0xad, 0x61, 0xc9, 0xf9, 0x9c, 0x15, 0xe8, 0x2f, 0xb3, 0xaa, 0x69,
	0xf5, 0xbe, 0xfb, 0xee, 0x1c, 0x42, 0x32, 0xd6, 0x89, 0x69, 0xd2, 0x91, 0xdc, 0x64, 0x4b, 0xff,
	0xe3, 0xb1, 0xf0, 0xb1, 0xcd, 0x60, 0x67, 0xad, 0xf5, 0x49, 0xc4, 0x40, 0x06, 0x92, 0x76, 0xbe,
	0xe5, 0xbe, 0xc1, 0xcc, 0xa4, 0x2f, 0x76, 0xf6, 0x3a, 0x5a, 0xec, 0x26, 0xed, 0x74, 0x7c, 0xb3,
	0xd0, 0x4d, 0xda, 0xfc, 0x76, 0xb8, 0x89, 0xe0, 0x33, 0x75, 0x3c, 0xce, 0x77, 0x93, 0x36, 0x1c,
	0x8e, 0x10, 0x51, 0xd1, 0x81, 0x2a, 0xf9, 0xb7, 0xbe, 0x29, 0x0e, 0x35, 0x9a, 0x88, 0x0d, 0x8a,
	0xd1, 0x6c, 0x12, 0x0d, 0x42, 0xa9, 0x24, 0xf2, 0x78, 0x0f, 0x3d, 0x51, 0x5a, 0x4b, 0xe8, 0xc9,
	0xf8, 0x71, 0x40, 0x93, 0xfc, 0xe3, 0x40, 0x32, 0x16, 0x9b, 0xec, 0x57, 0x05, 0x74, 0x2d, 0xb3,
	0x5e, 0x1a, 0xd0, 0x3e, 0xd5, 0x5e, 0xa3, 0xeb, 0x7d, 0x1a, 0x93, 0x30, 0x62, 0x20, 0x36, 0x09,
	0x89, 0xb4, 0x80, 0x14, 0x04, 0xf7, 0x69, 0xdc, 0x88, 0xd8, 0x01, 0x0d, 0x1a, 0x15, 0x6e, 0x87,
	0x8b, 0xdc, 0xe8, 0xb3, 0xf6, 0xe1, 0x5f, 0x14, 0xd0, 0xcd, 0x09, 0x7b, 0x9e, 0xb4, 0x23, 0xfa,
	0x1b, 0xed, 0xfb, 0xb4, 0x2c, 0xb3, 0x93, 0x65, 0x29, 0x4e, 0x90, 0x65, 0x2e, 0x2d, 0xcb, 0x7f,
	0x17, 0xd0, 0x46, 0x26, 0xdb, 0x81, 0x7d, 0xcd, 0x3a, 0x22, 0x70, 0xc2, 0x68, 0xb6, 0x13, 0xab,
	0xc4, 0x03, 0x3e, 0xa1, 0x27, 0x8a, 0x43, 0x65, 0x96, 0x28, 0x0e, 0x39, 0xc6, 0x57, 0x26, 0x87,
	0x4f, 0x8e, 0xf1, 0x03, 0xb9, 0x68, 0xf8, 0x84, 0xfc, 0x25, 0x8c, 0xe4, 0xcc, 0x33, 0x61, 0xc4,
	0x63, 0xf1, 0x8e, 0xcd, 0xaf, 0x8d, 0xfc, 0x58, 0xbc, 0x63, 0x0b, 0xb7, 0xb0, 0xe5, 0x25, 0x02,
	0x9f, 0x30, 0x92, 0x75, 0x6c, 0x7e, 0x81, 0xe4, 0x8e, 0x64, 0x62, 0x24, 0x8b, 0x6c, 0x79, 0xa1,
	0xc0, 0xa7, 0xfe, 0x36, 0x9b, 0x8c, 0xf1, 0x48, 0x88, 0x9e, 0xf1, 0x2b, 0x80, 0x47, 0xac, 0xca,
	0x91, 0x56, 0xcd, 0x05, 0x68, 0xef, 0xbb, 0xb1, 0xfe, 0x31, 0xbb, 0xb1, 0x20, 0xb2, 0xd8, 0x1e,
	0xe4, 0x08, 0x85, 0x61, 0x8e, 0x00, 0x7d, 0xa9, 0xb8, 0x88, 0x7f, 0x83, 0x89, 0x06, 0x31, 0xae,
	0x34, 0x91, 0x6a, 0xeb, 0x7f, 0x5d, 0x40, 0xeb, 0x13, 0x78, 0x93, 0xc0, 0x25, 0x41, 0xf2, 0xdb,
	0x98, 0x61, 0x24, 0xb7, 0x2b, 0x66, 0x72, 0xbb, 0x7b, 0x68, 0x99, 0xd9, 0x71, 0x9b, 0xb2, 0x74,
	0xb4, 0x89, 0x44, 0x17, 0x8f, 0x2a, 0xff, 0x6e, 0x8a, 0x78, 0xf6, 0x6f, 0x45, 0xbc, 0x07, 0x68,
	0x25, 0x4e, 0x42, 0x92, 0x11, 0x71, 0x39, 0x4e, 0x42, 0xf3, 0xb3, 0xa5, 0xdc, 0xcf, 0xba, 0xef,
	0x40, 0xc8, 0x30, 0x62, 0x13, 0xa5, 0x1c, 0xa6, 0xa9, 0x33, 0xe9, 0x34, 0x55, 0x3f, 0x43, 0x7a,
	0x3e, 0x27, 0x92, 0xf8, 0x36, 0x4f, 0x36, 0x7f, 0x03, 0x8e, 0xdc, 0xc9, 0x7d, 0x9b, 0x2f, 0x3b,
	0xdf, 0xc9, 0x7d, 0xfb, 0xa2, 0x99, 0xd9, 0xf7, 0x9a, 0x99, 0x5d, 0x34, 0x33, 0xf3, 0x6d, 0xfd,
	0xd1, 0xd8, 0x6d, 0x66, 0xc7, 0xc7, 0x63, 0xc5, 0x86, 0x67, 0x63, 0x28, 0xca, 0xb8, 0x07, 0x40,
	0x28, 0xa8, 0xe4, 0x81, 0x6f, 0x7d, 0x27, 0x5b, 0xbf, 0x68, 0xb3, 0x88, 0x44, 0x89, 0x03, 0x3b,
	0x2c, 0x72, 0x7b, 0xe9, 0xa4, 0x62, 0x21, 0x72, 0x7b, 0xfc, 0xd6, 0xc0, 0x68, 0xf6, 0xa4, 0xe5,
	0xa9, 0x03, 0xe5, 0xa4, 0xe5, 0xe9, 0x7f, 0x36, 0x76, 0xd1, 0x47, 0x51, 0x14, 0xf2, 0x1c, 0x57,
	0x25, 0xcb, 0x29, 0x46, 0x2a, 0x81, 0xb6, 0xf2, 0x5c, 0xf0, 0x0e, 0x42, 0x09, 0x4d, 0x44, 0x8e,
	0xad, 0x6a, 0x1c, 0x4b, 0xb2, 0xa7, 0xe6, 0xa6, 0x74, 0x58, 0x1c, 0xf1, 0x87, 0x9f, 0xa2, 0xdb,
	0x13, 0x84, 0x18, 0x64, 0xb5, 0x7c, 0x49, 0x2a, 0xc3, 0x55, 0x4b, 0x12, 0xd9, 0xad, 0xfe, 0xab,
	0x99, 0xec, 0x4d, 0x15, 0x24, 0xbc, 0x0e, 0x22, 0x45, 0x1d, 0x24, 0x93, 0xa2, 0x09, 0x17, 0x67,
	0x68, 0x77, 0x49, 0x74, 0xac, 0x22, 0xd0, 0xf9, 0xd0, 0xee, 0x1a, 0xc7, 0x6c, 0x6a, 0x71, 0x46,
	0x46, 0x15, 0xc5, 0x41, 0x54, 0x91, 0x5a, 0xc9, 0xdc, 0x88, 0x37, 0xdc, 0x46, 0x4b, 0x6a, 0xd4,
	0xa6, 0x8c, 0xd4, 0x87, 0x1d, 0x30, 0xaa, 0xeb, 0x72, 0x7d, 0x2e, 0xc8, 0x4b, 0x9b, 0xb7, 0x40,
	0x6d, 0xc3, 0x34, 0x5e, 0x06, 0xec, 0x4b, 0x83, 0x1c, 0x5e, 0x5d, 0xd8, 0x4b, 0xc3, 0x0b, 0xfb,
	0x06, 0x9a, 0x4f, 0x44, 0x4d, 0x0b, 0xc9, 0x0a, 0x93, 0x28, 0x6a, 0xfd, 0x79, 0x61, 0x2c, 0x75,
	0x6b, 0x77, 0xa3, 0x89, 0xfe, 0xac, 0xa3, 0xd5, 0xae, 0x7d, 0x06, 0x27, 0x42, 0x44, 0x98, 0xd7,
	0x55, 0x76, 0x5c, 0xee, 0xda, 0x67, 0x26, 0x4d, 0x22, 0xcb, 0xeb, 0x4e, 0x3f, 0x51, 0xee, 0x20,
	0xc4, 0x4b, 0x92, 0xe2, 0xb4, 0x90, 0x39, 0x26, 0xef, 0xe1, 0x87, 0xc5, 0x5f, 0x16, 0xb2, 0x35,
	0x3b, 0xbb, 0x33, 0xe5, 0xf0, 0xbf, 0x38, 0xc9, 0xbf, 0xc0, 0x3e, 0xa0, 0xa0, 0xe2, 0x50, 0x41,
	0x37, 0xd1, 0x02, 0xcf, 0x6e, 0x7b, 0x5d, 0x65, 0xa0, 0x84, 0x9e, 0xd4, 0x7b, 0x5d, 0xfd, 0x6f,
	0x66, 0x44, 0x21, 0xac, 0xe3, 0xb5, 0xbd, 0xf6, 0x16, 0x69, 0x89, 0x22, 0xd4, 0x71, 0x12, 0xaa,
	0x42, 0x2b, 0xff, 0x86, 0x7d, 0xc9, 0x1c, 0x29, 0xc5, 0x0c, 0xe3, 0x98, 0xae, 0x93, 0x30, 0x55,
	0xa8, 0x82, 0x6f, 0xe8, 0x8b, 0x69, 0xd2, 0x57, 0xa1, 0x16, 0x7c, 0xf3, 0xc4, 0x35, 0x61, 0xa4,
	0x1b, 0xba, 0x9e, 0xab, 0x4a, 0xaa, 0x6e, 0xc2, 0x0e, 0xa1, 0x0d, 0x42, 0xf1, 0xf4, 0xc7, 0x53,
	0x15, 0xd5, 0x79, 0xc8, 0x7e, 0x3c, 0x17, 0x46, 0x41, 0xca, 0x24, 0x46, 0x09, 0xd7, 0x80, 0x1c,
	0x6a, 0x30, 0x8a, 0xe7, 0x53, 0x9e, 0x2b, 0x3d, 0x63, 0x1e, 0xd2, 0x29, 0xcf, 0x85, 0xf9, 0xfd,
	0x4f, 0x9e, 0x2b, 0xfd, 0x82, 0x7f, 0xf3, 0x9d, 0x12, 0xb9, 0x62, 0xcf, 0x2e, 0xcb, 0x9d, 0x12,
	0xb9, 0x7c, 0xbf, 0x42, 0x50, 0x42, 0x93, 0xfe, 0x66, 0x69, 0x45, 0x06, 0x25, 0xd0, 0x80, 0x85,
	0xba, 0x51, 0x69, 0x55, 0x2c, 0xd4, 0x8d, 0xf4, 0xbf, 0x2d, 0x8a, 0xf0, 0x4d, 0xea, 0x27, 0x8a,
	0x18, 0x67, 0xf6, 0x86, 0xfb, 0xae, 0x17, 0xc7, 0xa1, 0xb2, 0x9c, 0x6c, 0x81, 0xe1, 0xc4, 0x17,
	0x71, 0xc3, 0x40, 0x79, 0x11, 0x12, 0x5d, 0x3b, 0x61, 0x40, 0x53, 0x80, 0x30, 0xf0, 0xcf, 0xa5,
	0x06, 0x25, 0xa0, 0x11, 0xf8, 0xe7, 0xda, 0x63, 0xb4, 0x26, 0x0b, 0xd5, 0x90, 0x22, 0xb5, 0x07,
	0xb7, 0xd3, 0xaa, 0xec, 0xb5, 0x78, 0xa7, 0x4a, 0x1e, 0x59, 0x7b, 0xa0, 0x59, 0xd0, 0xa6, 0xd5,
	0xf6, 0x5c, 0xed, 0x2a, 0x9a, 0xe3, 0x24, 0xa9, 0xd6, 0x22, 0xf4, 0x83, 0x52, 0xfb, 0x0e, 0xe1,
	0x99, 0xc1, 0x96, 0x52, 0x6a, 0xdf, 0x39, 0xe0, 0x6d, 0xed, 0x21, 0x5a, 0x15, 0x59, 0x44, 0x04,
	0x4e, 0x14, 0x30, 0xa9, 0xda, 0x15, 0xde, 0x69, 0x88, 0x3e, 0xd0, 0x8d, 0xff, 0x56, 0xaa, 0x77,
	0xc6, 0x7f, 0x0b, 0x6e, 0x16, 0xd3, 0x44, 0x6e, 0x39, 0xf8, 0x4c, 0xcf, 0xb1, 0x29, 0xf5, 0xad,
	0xe6, 0xd8, 0x4c, 0x13, 0xdf, 0x48, 0xa5, 0x2b, 0xe2, 0x1b, 0x5e, 0xef, 0xf2, 0x5c, 0x50, 0x73,
	0x47, 0x6a, 0x7f, 0xa1, 0xef, 0xb9, 0xfb, 0x5e, 0xbb, 0x03, 0x06, 0x07, 0x92, 0x1f, 0x9e, 0x96,
	0xd6, 0x84, 0xaa, 0xfb, 0x9e, 0x7b, 0x10, 0x9e, 0xc2, 0xfc, 0x61, 0xe4, 0x94, 0x2e, 0x8b, 0xf9,
	0xc3, 0xc8, 0x91, 0x2e, 0xb8, 0x59, 0xc2, 0x03, 0x17, 0xdc, 0x84, 0x8c, 0x2f, 0x89, 0x1d, 0x4a,
	0x58, 0xe9, 0x8a, 0x30, 0x34, 0xb4, 0x2c, 0x58, 0x4c, 0xd4, 0x2a, 0x69, 0x62, 0x31, 0x51, 0x4b,
	0x0e, 0xdd, 0x2a, 0x5d, 0x1d, 0x0c, 0xdd, 0xd2, 0x1e, 0xa1, 0xb5, 0x8e, 0x1b, 0x43, 0x9c, 0xa6,
	0x6a, 0x9b, 0xd7, 0x84, 0x5a, 0x3a, 0x6e, 0x5c, 0x3d, 0x63, 0xa2, 0xb8, 0xa9, 0xff, 0x4f, 0x61,
	0xa2, 0x8b, 0x6c, 0x6a, 0x4f, 0xd0, 0x9a, 0xe3, 0xdb, 0x49, 0xe2, 0xb5, 0x3c, 0xc7, 0x66, 0xc3,
	0xc3, 0x37, 0xd3, 0x3b, 0xd8, 0x38, 0x33, 0xa9, 0x8d, 0x03, 0x41, 0xf4, 0xe0, 0xca, 0x80, 0x4f,
	0x5e, 0x11, 0x8f, 0xf8, 0x0d, 0x23, 0x2f, 0x0b, 0xd1, 0x1a, 0xfa, 0xf1, 0x5c, 0xda, 0x8f, 0xaf,
	0x22, 0x58, 0xe7, 0xd0, 0x05, 0x92, 0xd8, 0xb1, 0x78, 0x70, 0xdc, 0xea, 0xaa, 0x90, 0x36, 0x6a,
	0x75, 0xd5, 0xe0, 0x2d, 0x55, 0x15, 0xe1, 0x0d, 0x48, 0x07, 0x53, 0xeb, 0x96, 0x16, 0x5f, 0x1a,
	0x2c, 0x5a, 0xff, 0xab, 0xc2, 0xc8, 0xa1, 0x01, 0x49, 0xd4, 0x13, 0x34, 0xdb, 0x72, 0xe2, 0xf1,
	0x4a, 0xf8, 0xf0, 0x5c, 0x31, 0x01, 0xa0, 0xbd, 0x42, 0xc5, 0x28, 0x62, 0x6f, 0x64, 0x29, 0x7c,
	0x63, 0x0c, 0x38, 0xd8, 0x60, 0x26, 0xc7, 0x49, 0xfc, 0xa6, 0x8c, 0x27, 0xf2, 0xf1, 0x9b, 0x1c,
	0xbf, 0xa9, 0x7f, 0x85, 0x4a, 0xa3, 0xc7, 0xec, 0xa8, 0x8c, 0xc3, 0x7c, 0x6d, 0x5c, 0xc6, 0x41,
	0xca, 0xf6, 0x8b, 0xb1, 0xda, 0x8f, 0xdd, 0x9e, 0x14, 0x73, 0x0c, 0x5f, 0x52, 0x66, 0xd2, 0x2f,
	0x29, 0x5f, 0x66, 0x53, 0x2c, 0x7f, 0x8b, 0x45, 0xfd, 0xb7, 0xa1, 0x17, 0x65, 0xe2, 0x81, 0x42,
	0x26, 0x1e, 0xd0, 0xff, 0x25, 0xfd, 0xea, 0x05, 0x43, 0xb5, 0x17, 0xa9, 0x9b, 0x6a, 0x6d, 0xab,
	0x34, 0x94, 0x39, 0x25, 0xdc, 0x79, 0x44, 0xe5, 0x1d, 0xf6, 0x0c, 0x15, 0x93, 0x88, 0x0e, 0xdf,
	0x19, 0xc4, 0xfb, 0xda, 0x2b, 0xf5, 0xbe, 0xf6, 0xaa, 0x1c, 0x9c, 0x9b, 0x1c, 0x01, 0x48, 0xdf,
	0x96, 0xe7, 0x77, 0x2e, 0x12, 0x10, 0x80, 0xe4, 0x6f, 0x56, 0xc5, 0x69, 0x48, 0x40, 0xe8, 0x4f,
	0x52, 0x89, 0xae, 0xed, 0x80, 0x67, 0x4f, 0x8e, 0xe9, 0x5e, 0x8c, 0xe3, 0xfe, 0xb0, 0xd7, 0x8d,
	0x26, 0xbf, 0xf0, 0xe9, 0x2f, 0x53, 0x71, 0x9d, 0x44, 0x9f, 0xf4, 0x68, 0x8f, 0xe6, 0x3c, 0x63,
	0xfd, 0x72, 0x1c, 0xee, 0x84, 0xbd, 0x80, 0x3f, 0x11, 0x25, 0x1d, 0x3b, 0xa6, 0x4a, 0x12, 0xd9,
	0x1a, 0xb9, 0x47, 0x67, 0x32, 0xf7, 0xa8, 0x90, 0x7c, 0x76, 0x20, 0xf9, 0x3f, 0xa4, 0x73, 0xf9,
	0x93, 0x1e, 0x8d, 0xcf, 0x25, 0x73, 0xb1, 0x8d, 0xa8, 0x2a, 0xf0, 0x89, 0x06, 0x9c, 0x69, 0x1d,
	0x8f, 0x25, 0x04, 0x08, 0xb2, 0x5e, 0x01, 0xed, 0x26, 0xe5, 0x05, 0x5d, 0xfe, 0xce, 0xc4, 0x69,
	0xf2, 0xfa, 0xe6, 0x1d, 0x40, 0x9c, 0x96, 0x3b, 0x69, 0xa8, 0x08, 0x3c, 0xf8, 0x66, 0x2f, 0x9a,
	0xfc, 0x1b, 0x66, 0x17, 0x8f, 0x56, 0xf3, 0xbc, 0x53, 0x34, 0xf4, 0xff, 0x48, 0x87, 0xb2, 0x52,
	0x15, 0x71, 0x92, 0x68, 0xaf, 0x51, 0xb1, 0xd5, 0x0b, 0x1c, 0xe9, 0x52, 0xb7, 0x46, 0x22, 0x74,
	0xd2, 0xb1, 0x93, 0x0e, 0x01, 0x32, 0xc0, 0x4d, 0x0e, 0xe4, 0x4f, 0x6e, 0xb4, 0x4f, 0x55, 0xd1,
	0x41, 0x34, 0xa0, 0x17, 0x7c, 0x4e, 0xbc, 0xad, 0x16, 0x4d, 0xd1, 0x80, 0xb3, 0xfa, 0x98, 0x9e,
	0xf3, 0x53, 0x43, 0x9e, 0x52, 0xc7, 0xf4, 0x1c, 0xc2, 0x95, 0x5b, 0x68, 0x89, 0x9b, 0x2d, 0x15,
	0x82, 0x2c, 0xf2, 0x8e, 0x7a, 0xaf, 0x0b, 0xe7, 0xd2, 0x31, 0x3d, 0x97, 0x47, 0x15, 0x7c, 0x02,
	0x77, 0x4e, 0x55, 0x35, 0x5c, 0xde, 0xd0, 0xff, 0x20, 0x15, 0xcd, 0xc9, 0x15, 0xf5, 0x5b, 0x23,
	0xea, 0x2a, 0x64, 0xd4, 0xb5, 0x81, 0x16, 0xc3, 0xd8, 0x6b, 0x7b, 0x81, 0x3d, 0xa8, 0x99, 0xa8,
	0xf6, 0x98, 0x75, 0x3b, 0xa9, 0xa3, 0x43, 0x72, 0x1f, 0xbc, 0x99, 0xa6, 0xf9, 0x14, 0x32, 0x7c,
	0xa6, 0x79, 0xd0, 0xc0, 0x49, 0x67, 0xd3, 0x4e, 0x6a, 0xa7, 0x4e, 0x08, 0x35, 0x93, 0x7c, 0x6d,
	0xfd, 0xbe, 0x13, 0x65, 0x17, 0xf3, 0x6a, 0x7c, 0x1f, 0x74, 0x29, 0xa3, 0x31, 0x5c, 0x87, 0x5d,
	0x16, 0x0f, 0x8f, 0x9f, 0xb9, 0x2e, 0x8b, 0x6b, 0xae, 0xfe, 0xcb, 0xf1, 0xc5, 0x27, 0xd4, 0xe9,
	0xf1, 0x87, 0xf4, 0xdf, 0x43, 0x58, 0x7d, 0x13, 0x79, 0x58, 0x0d, 0x0e, 0xd1, 0x49, 0xc7, 0xc1,
	0x65, 0x85, 0x6e, 0x0a, 0xb0, 0xfe, 0x73, 0x74, 0x2f, 0xcb, 0x9c, 0x3f, 0x2a, 0x32, 0x5e, 0xc2,
	0x24, 0x90, 0x40, 0xac, 0xa3, 0x45, 0xf5, 0xad, 0x42, 0x61, 0x68, 0x5b, 0xcc, 0xd7, 0xb7, 0xd1,
	0x9d, 0x9c, 0xd1, 0xc1, 0x29, 0x1f, 0x7b, 0x1d, 0xcd, 0x8b, 0x2f, 0xb5, 0xa4, 0xe0, 0x14, 0xc6,
	0xfd, 0x3c, 0x95, 0x45, 0x0d, 0xc7, 0x45, 0xbd, 0xa4, 0x23, 0x9e, 0x50, 0x6f, 0xa3, 0x25, 0x9e,
	0x94, 0xa6, 0x52, 0x81, 0x61, 0xc7, 0x14, 0x99, 0x61, 0x30, 0xe9, 0x8b, 0xe0, 0x52, 0x7d, 0x0f,
	0xd2, 0x2a, 0xdf, 0x0e, 0xde, 0x7b, 0xee, 0x45, 0xa3, 0x23, 0x27, 0x1a, 0x8c, 0x8e, 0x9c, 0x28,
	0x3d, 0xda, 0x70, 0x22, 0xfd, 0x67, 0xe8, 0xd6, 0x24, 0xc9, 0xc3, 0x48, 0x95, 0x7c, 0xa7, 0x0b,
	0x9e, 0xbb, 0xec, 0xcf, 0x18, 0x6d, 0x8e, 0x4f, 0x2d, 0x2a, 0x84, 0x34, 0x70, 0xec, 0x48, 0x7b,
	0x8b, 0x90, 0x4b, 0x5b, 0x5e, 0xe0, 0xb1, 0xa1, 0x13, 0x5c, 0x9d, 0x70, 0x2b, 0x99, 0x29, 0xd8,
	0x24, 0x9e, 0xbc, 0x7c, 0xfe, 0x43, 0x78, 0x92, 0x54, 0x85, 0x48, 0x1d, 0x6e, 0xf6, 0xa9, 0xe4,
	0x38, 0xe9, 0xae, 0xe6, 0x15, 0x4b, 0xb1, 0x5b, 0x86, 0xd5, 0x53, 0xd1, 0x06, 0x7c, 0xe2, 0x7d,
	0x37, 0x78, 0x76, 0x87, 0x6f, 0xbd, 0x32, 0x79, 0x02, 0x97, 0xe6, 0x4d, 0xa0, 0x98, 0xcc, 0xa4,
	0x98, 0xfc, 0xce, 0xa4, 0x5d, 0xc5, 0x44, 0x7d, 0xf3, 0x16, 0x5a, 0xe2, 0x6f, 0xc0, 0x3c, 0x5f,
	0x54, 0xaf, 0x9d, 0x51, 0xff, 0x0b, 0x9e, 0x2e, 0xe6, 0x0f, 0xdc, 0x96, 0x03, 0xb7, 0xd5, 0xc0,
	0x59, 0x39, 0x70, 0x9b, 0x0f, 0x7c, 0x91, 0xaa, 0x34, 0xa6, 0x06, 0x32, 0x2e, 0x73, 0xea, 0x0d,
	0x8a, 0x7f, 0xeb, 0xdb, 0xe3, 0x07, 0x11, 0x47, 0x33, 0x9f, 0xbf, 0xb1, 0x31, 0x9f, 0xf4, 0x6d,
	0xbf, 0x37, 0x78, 0x8c, 0x65, 0xcc, 0x7f, 0x0f, 0xed, 0xbc, 0x71, 0x5d, 0xdb, 0x81, 0x71, 0x5d,
	0x5b, 0xbc, 0x23, 0xb7, 0x94, 0x74, 0x5d, 0x9b, 0x3f, 0x24, 0xb7, 0xf4, 0x0f, 0x39, 0xf3, 0xe5,
	0xc4, 0x57, 0x9a, 0x8c, 0x3d, 0xa4, 0x4a, 0xf9, 0x6f, 0x6a, 0x26, 0x9f, 0xa8, 0x5f, 0x4d, 0xd6,
	0x57, 0x5e, 0xb5, 0x68, 0x12, 0x67, 0xfd, 0xd5, 0x64, 0x1e, 0x6e, 0xe2, 0x08, 0x83, 0x27, 0x83,
	0x8d, 0xca, 0xbf, 0xf5, 0x63, 0x74, 0x39, 0x83, 0x87, 0x68, 0x35, 0x15, 0xae, 0x6d, 0x64, 0x9c,
	0x58, 0x32, 0x1d, 0x0d, 0xd8, 0x9c, 0x30, 0x68, 0x4d, 0x0f, 0xd8, 0x00, 0xa1, 0xff, 0x91, 0x88,
	0xb8, 0x39, 0x1f, 0xca, 0x13, 0xcd, 0x97, 0x23, 0x73, 0xad, 0x67, 0xe6, 0xe2, 0x98, 0xf4, 0x54,
	0xcf, 0xd1, 0x9c, 0x63, 0xf7, 0x12, 0x3a, 0x75, 0x2e, 0x01, 0xe1, 0xda, 0xa1, 0x89, 0x78, 0x7d,
	0x5c, 0x32, 0xf9, 0xb7, 0xfe, 0x75, 0x2a, 0xf4, 0xf1, 0xbd, 0x84, 0x91, 0x98, 0x26, 0x3d, 0x9f,
	0xa5, 0x9f, 0xab, 0x0a, 0xe9, 0xe7, 0x2a, 0xed, 0x3e, 0x5a, 0x76, 0x69, 0xe2, 0xc4, 0x5e, 0xc4,
	0xf7, 0xf5, 0x0c, 0xe7, 0x95, 0xee, 0xd2, 0xff, 0xa9, 0x80, 0xae, 0x98, 0xf4, 0xa4, 0x47, 0x13,
	0xb6, 0xeb, 0x87, 0xa7, 0x95, 0x98, 0xda, 0x8c, 0x3f, 0xe5, 0xc8, 0xcb, 0x50, 0x31, 0x84, 0x26,
	0xff, 0x9d, 0x48, 0xd1, 0x66, 0x2c, 0x96, 0x0b, 0xc8, 0x9e, 0x10, 0x40, 0x32, 0x39, 0x40, 0x7b,
	0x39, 0xfc, 0xd5, 0xcf, 0xec, 0xfd, 0xd9, 0xbc, 0xd3, 0x44, 0x61, 0xb4, 0x97, 0x68, 0x5e, 0x58,
	0xa6, 0x54, 0xe4, 0xe8, 0xeb, 0x13, 0xcd, 0x66, 0x4a, 0x90, 0x5e, 0x1d, 0x11, 0x3a, 0x6c, 0xf1,
	0xe7, 0xda, 0x5c, 0xa1, 0x53, 0xea, 0x99, 0x19, 0x79, 0xcd, 0x7b, 0x86, 0x56, 0x25, 0x9b, 0x0b,
	0x58, 0xe8, 0x75, 0xb4, 0x26, 0x91, 0xb5, 0x24, 0xf4, 0xa7, 0xaa, 0xe8, 0x21, 0x5a, 0xf5, 0x04,
	0xc6, 0x25, 0xdd, 0x61, 0x31, 0x72, 0x45, 0x75, 0x1e, 0x86, 0x2e, 0xd5, 0x35, 0x84, 0x25, 0xbf,
	0x03, 0x4f, 0xbc, 0x36, 0x27, 0xba, 0x8b, 0xae, 0x00, 0x8b, 0x84, 0x78, 0x41, 0x2b, 0x8c, 0xbb,
	0x22, 0x2f, 0xcd, 0x9d, 0x66, 0x1d, 0x2d, 0x72, 0x42, 0xe4, 0x78, 0xd2, 0xae, 0x1c, 0x68, 0x38,
	0x1e, 0xff, 0xa5, 0x0f, 0x90, 0xf8, 0xec, 0xc2, 0x7f, 0x38, 0x96, 0xcf, 0x5c, 0x41, 0x2b, 0x26,
	0x4d, 0xa2, 0x30, 0x48, 0x28, 0xff, 0x25, 0xcb, 0x5b, 0x84, 0x84, 0x9f, 0xc2, 0xac, 0xe3, 0x79,
	0xd9, 0xd0, 0x91, 0xcd, 0x25, 0xfe, 0xa7, 0x16, 0xb4, 0x42, 0xfd, 0x13, 0xd2, 0xd2, 0x4c, 0x86,
	0x5e, 0x33, 0xd9, 0x0d, 0x47, 0xe7, 0x98, 0xf9, 0xbc, 0x39, 0xce, 0xc0, 0xc6, 0xc3, 0x39, 0xbe,
	0x86, 0x50, 0xff, 0x7b, 0x49, 0x0b, 0x27, 0x02, 0x3f, 0x7c, 0xc6, 0xf2, 0xdd, 0x6c, 0x0e, 0x21,
	0xcb, 0xd8, 0xfb, 0x60, 0x9c, 0xe1, 0xcc, 0x60, 0x21, 0xed, 0x0b, 0xb4, 0x20, 0x36, 0x5b, 0xc2,
	0x0f, 0xd4, 0x71, 0x36, 0xa9, 0xfd, 0x68, 0x2a, 0xa8, 0x5e, 0x1e, 0x72, 0x02, 0x1b, 0x73, 0x4e,
	0x2f, 0xd1, 0x1c, 0x37, 0xb3, 0xe4, 0x73, 0x53, 0xf0, 0x19, 0xb3, 0xbc, 0x29, 0x50, 0xcf, 0xff,
	0x6f, 0x39, 0x5b, 0x3e, 0xe5, 0x47, 0xc9, 0x06, 0xba, 0x61, 0x5a, 0x55, 0xb2, 0x7b, 0xd0, 0xf8,
	0x40, 0x6a, 0x56, 0xf5, 0x90, 0x58, 0x1f, 0x8d, 0x2a, 0xa9, 0xd6, 0x77, 0xf0, 0x25, 0xed, 0x16,
	0xba, 0x39, 0x81, 0xf6, 0xbe, 0x51, 0xdb, 0xc1, 0x05, 0xed, 0x0e, 0x5a, 0x9f, 0x40, 0xac, 0xd5,
	0xdf, 0x57, 0x4d, 0x0b, 0xcf, 0xe4, 0xf0, 0x2d, 0xd7, 0x3f, 0xe2, 0x59, 0x6d, 0x1d, 0x5d, 0x9f,
	0x40, 0x33, 0x76, 0x71, 0x31, 0x87, 0xf4, 0x7e, 0x17, 0xcf, 0x69, 0xf7, 0xd0, 0xad, 0x49, 0xa3,
	0xf6, 0x3f, 0x12, 0xa3, 0x61, 0x5a, 0x78, 0x5e, 0xbb, 0x8b, 0x36, 0x26, 0x01, 0x1a, 0xa6, 0x45,
	0x6a, 0x3b, 0x78, 0x21, 0x47, 0x24, 0xb3, 0xfc, 0x01, 0x2f, 0xe6, 0xa9, 0xc1, 0xda, 0xc7, 0x4b,
	0x79, 0x6a, 0x38, 0x28, 0xd7, 0x31, 0xca, 0x21, 0xd6, 0x8c, 0xf7, 0x5f, 0xe0, 0xe5, 0x7c, 0xe2,
	0x36, 0x5e, 0xc9, 0x23, 0x56, 0x0e, 0x0d, 0xbc, 0x9a, 0x23, 0xcf, 0xd1, 0x8e, 0x81, 0xd7, 0x72,
	0x68, 0x56, 0xc5, 0xc0, 0x97, 0x73, 0x98, 0x36, 0x2b, 0x96, 0x81, 0xb1, 0x76, 0x1b, 0x95, 0x26,
	0x2d, 0xe4, 0x1b, 0x58, 0xc9, 0x95, 0x1c, 0x6a, 0x95, 0x58, 0xe5, 0x3d, 0xac, 0xe5, 0x50, 0xeb,
	0xef, 0xf7, 0xcc, 0x2a, 0xbe, 0x9a, 0x33, 0xed, 0xa1, 0x71, 0xd0, 0xc4, 0xd7, 0x72, 0xe4, 0x85,
	0x81, 0xd7, 0x73, 0xd8, 0xee, 0x1e, 0x7d, 0xfb, 0xed, 0x47, 0x7c, 0x23, 0x6f, 0xa4, 0x65, 0xe0,
	0x9b, 0x39, 0x53, 0xee, 0x59, 0x46, 0x05, 0x97, 0xf2, 0x89, 0x47, 0x78, 0x3d, 0xcf, 0xd6, 0x4d,
	0x03, 0x6f, 0xe4, 0x78, 0xf5, 0x5e, 0xb5, 0x5e, 0x7d, 0x5f, 0xc5, 0xb7, 0xb4, 0xfb, 0xe8, 0x76,
	0x9e, 0x06, 0xc9, 0x9e, 0x51, 0xc5, 0xb7, 0xb5, 0x87, 0xe8, 0xde, 0x24, 0xbf, 0x37, 0x0d, 0x70,
	0x26, 0xe1, 0x17, 0x77, 0x72, 0x5c, 0x19, 0xfc, 0x82, 0x54, 0xbf, 0xb1, 0xf0, 0xdd, 0x1c, 0xb5,
	0x80, 0x6f, 0x6c, 0xe3, 0x7b, 0x9a, 0x8e, 0xee, 0xe6, 0x51, 0x49, 0x7d, 0x87, 0xd4, 0x9b, 0xf8,
	0xfe, 0x85, 0x98, 0x32, 0x7e, 0x90, 0x23, 0xeb, 0x00, 0xd3, 0x30, 0x2c, 0xac, 0x6b, 0x3f, 0x46,
	0x4f, 0x2f, 0x00, 0x91, 0xe6, 0x41, 0x99, 0x6f, 0x95, 0x87, 0x9f, 0x03, 0xb6, 0x24, 0xf8, 0x51,
	0x9e, 0xd3, 0x94, 0xcd, 0x77, 0xf8, 0x71, 0x1e, 0xb1, 0x6a, 0x95, 0xf1, 0x93, 0x9c, 0x9d, 0xbe,
	0x67, 0x56, 0xc9, 0xbb, 0xea, 0x47, 0xfc, 0x34, 0x8f, 0x6e, 0x19, 0xc4, 0x68, 0x56, 0xf0, 0xb3,
	0x1c, 0x2b, 0x1b, 0x86, 0xd1, 0xa8, 0x36, 0xf1, 0x8f, 0xa6, 0x91, 0x77, 0xf0, 0x73, 0xed, 0x31,
	0x7a, 0x90, 0x47, 0x26, 0x86, 0xd9, 0xb0, 0x1a, 0x70, 0xdc, 0xfc, 0x38, 0xc7, 0xcd, 0xea, 0xcd,
	0x7d, 0xfc, 0x22, 0x6f, 0xef, 0xef, 0x1d, 0x1a, 0xf8, 0x65, 0xce, 0x19, 0x58, 0xde, 0xc7, 0xaf,
	0x72, 0x24, 0xdb, 0xaf, 0xed, 0xd5, 0xf6, 0xb6, 0xf0, 0xeb, 0xbc, 0x93, 0xa1, 0xbc, 0x87, 0xdf,
	0x3c, 0xff, 0xcf, 0x82, 0xa8, 0x22, 0x8c, 0x55, 0x86, 0xb4, 0x07, 0xe8, 0x0e, 0x8c, 0x02, 0xff,
	0xdc, 0x2f, 0x37, 0xf7, 0xc9, 0xee, 0x51, 0xbd, 0x62, 0xd5, 0x1a, 0x75, 0xb2, 0x53, 0xdd, 0x2d,
	0x1f, 0x1d, 0x58, 0xf8, 0x92, 0xf2, 0xa6, 0x71, 0x88, 0xd5, 0xa8, 0x1a, 0x07, 0x35, 0xeb, 0x5b,
	0x5c, 0xd0, 0x1e, 0xa1, 0xfb, 0x93, 0x31, 0xcd, 0xda, 0xa1, 0x71, 0x50, 0x25, 0xdf, 0x34, 0x4c,
	0x3c, 0xa3, 0xbd, 0x40, 0xcf, 0x72, 0x50, 0x1f, 0x0f, 0x0f, 0xab, 0x96, 0x59, 0xab, 0x0c, 0x79,
	0xce, 0xaa, 0xf5, 0x8e, 0xa3, 0x0f, 0xcb, 0xdf, 0xe0, 0xe2, 0xf3, 0x7f, 0x5f, 0x1b, 0x2f, 0x3f,
	0xf2, 0x5b, 0x2d, 0xbd, 0x7f, 0xca, 0x52, 0xd2, 0xe1, 0xbd, 0x96, 0xd6, 0x62, 0x9a, 0x2a, 0x6f,
	0x36, 0xa9, 0x8f, 0x31, 0xb2, 0x51, 0x6e, 0x36, 0xad, 0x7d, 0xf3, 0x08, 0xcf, 0xe4, 0x72, 0xf8,
	0xfd, 0xa3, 0x43, 0x63, 0x28, 0xf6, 0x18, 0x99, 0xfb, 0x76, 0x31, 0x97, 0xbc, 0x7b, 0x50, 0xde,
	0xc3, 0x73, 0x23, 0xde, 0x9b, 0x26, 0x7f, 0x7d, 0x54, 0x3d, 0xaa, 0xe2, 0xf9, 0xdc, 0xe1, 0x3b,
	0x66, 0xc3, 0xc0, 0x0b, 0xb9, 0xc3, 0x2b, 0x8d, 0xa3, 0xba, 0x85, 0x17, 0x73, 0x75, 0x63, 0x36,
	0x9b, 0x99, 0xcb, 0x6e, 0x64, 0xf1, 0xbb, 0x99, 0xcb, 0x6e, 0x44, 0x71, 0xbb, 0x78, 0x39, 0x5f,
	0x6d, 0xea, 0x86, 0x5e, 0x19, 0x39, 0x3e, 0x47, 0x20, 0xf2, 0x8e, 0x5e, 0xcd, 0x15, 0xfe, 0xb0,
	0x6a, 0x55, 0x4d, 0xbc, 0x96, 0x3b, 0x49, 0xb3, 0x5a, 0x39, 0x32, 0x6b, 0xd6, 0x47, 0x7c, 0x59,
	0x7b, 0x86, 0x1e, 0x4d, 0x84, 0x34, 0x76, 0x49, 0xb3, 0x6a, 0xf1, 0x4b, 0x89, 0x58, 0xd6, 0x01,
	0xc6, 0xd3, 0x90, 0x3b, 0xd5, 0xca, 0x10, 0x79, 0x45, 0x7b, 0x82, 0xf4, 0x69, 0x3c, 0xeb, 0x1f,
	0x38, 0x4e, 0x9b, 0x86, 0x03, 0x8e, 0x12, 0x77, 0x75, 0xda, 0xcc, 0x95, 0x86, 0xf1, 0x11, 0x50,
	0xa4, 0x71, 0x64, 0xe1, 0x6b, 0xda, 0x53, 0xf4, 0xf0, 0x42, 0x64, 0xad, 0x8e, 0xaf, 0xab, 0xed,
	0x37, 0x09, 0x68, 0x34, 0x0c, 0x11, 0xae, 0xdc, 0x18, 0x39, 0xbb, 0xb2, 0xa8, 0xa3, 0xe6, 0xbe,
	0x80, 0xdd, 0xbc, 0x48, 0x87, 0x80, 0x22, 0xef, 0x6b, 0x3b, 0xb8, 0xf4, 0x59, 0x48, 0xa3, 0x62,
	0xe0, 0xf5, 0x8b, 0x04, 0xe4, 0xc1, 0xc2, 0xc6, 0x85, 0x02, 0x72, 0xd8, 0xad, 0x5c, 0x66, 0xe2,
	0x2a, 0xae, 0xd6, 0x2b, 0x65, 0x03, 0xdf, 0xbe, 0x00, 0xb5, 0x53, 0x05, 0xd4, 0x9d, 0x5c, 0x14,
	0x0f, 0x6e, 0x24, 0xaf, 0xbb, 0x17, 0xa0, 0x04, 0xaf, 0xd1, 0xab, 0x79, 0x64, 0x73, 0x95, 0x3f,
	0x48, 0x4e, 0xf7, 0xa7, 0x62, 0x04, 0x9f, 0x07, 0xb9, 0x6a, 0x00, 0x9d, 0x42, 0x10, 0x41, 0x9a,
	0x66, 0x05, 0xeb, 0x17, 0xc3, 0x76, 0x9a, 0x16, 0x7e, 0x78, 0x11, 0x6c, 0x9b, 0x73, 0x7b, 0x74,
	0x31, 0x0c, 0xb8, 0x3d, 0x1e, 0x09, 0x1b, 0xb2, 0x30, 0xcb, 0xe0, 0xbc, 0x9e, 0x5c, 0x04, 0x02,
	0x4e, 0x4f, 0x73, 0x77, 0xf3, 0x61, 0xb9, 0x42, 0x9a, 0x1f, 0xca, 0x06, 0x7e, 0x96, 0x7b, 0x64,
	0xc0, 0x76, 0x82, 0xbd, 0xf4, 0xa3, 0x5c, 0x04, 0x9f, 0xc9, 0x3a, 0xc0, 0xcf, 0x73, 0x4d, 0xc7,
	0x8f, 0x03, 0x98, 0xca, 0xac, 0xe0, 0x1f, 0x5f, 0x88, 0x02, 0x91, 0x5f, 0xe4, 0xa2, 0x6a, 0xf5,
	0x0a, 0x84, 0xe0, 0xa4, 0x59, 0xfd, 0x1a, 0xbf, 0xcc, 0x45, 0x71, 0xa9, 0x25, 0xea, 0xd5, 0x85,
	0xbc, 0xca, 0x95, 0x77, 0xf8, 0xf5, 0x85, 0xbc, 0x00, 0xf5, 0x66, 0xba, 0x16, 0xca, 0x7b, 0x78,
	0x73, 0xca, 0xd1, 0x69, 0x89, 0xb8, 0x6a, 0xeb, 0xf9, 0x7f, 0x15, 0x53, 0xcf, 0x4c, 0xc3, 0xaa,
	0xd3, 0xc8, 0x95, 0x51, 0x35, 0xcd, 0x86, 0x29, 0x5d, 0xbf, 0x51, 0xaf, 0xe2, 0x4b, 0x23, 0xa6,
	0x4e, 0x51, 0x8f, 0xea, 0x4d, 0xa3, 0x5a, 0xa9, 0xed, 0xd6, 0xaa, 0x70, 0xa9, 0xa6, 0x0f, 0xf6,
	0x14, 0x68, 0xbf, 0x5c, 0xdf, 0x39, 0xa8, 0xe2, 0x99, 0x91, 0x4d, 0x91, 0xa2, 0x97, 0x2d, 0xcb,
	0x24, 0x7b, 0x66, 0xe3, 0x08, 0xae, 0xd5, 0xb4, 0x7f, 0x66, 0x31, 0x86, 0x59, 0x6b, 0xf0, 0x0b,
	0xa0, 0x38, 0xa2, 0xb0, 0x2c, 0xac, 0x56, 0xdf, 0x33, 0xab, 0xcd, 0x26, 0x9e, 0xcb, 0x93, 0x9a,
	0xa3, 0xaa, 0x02, 0x34, 0x3f, 0x75, 0x46, 0xcb, 0x2c, 0xd7, 0x9b, 0xbb, 0x55, 0x13, 0x2f, 0xe4,
	0xe9, 0x07, 0x60, 0x78, 0x71, 0xc4, 0x34, 0x29, 0x2a, 0x0f, 0xd0, 0xea, 0x47, 0x87, 0x78, 0x69,
	0xc4, 0x34, 0x59, 0x04, 0x28, 0x11, 0xa3, 0xa9, 0x90, 0x83, 0x72, 0xd3, 0xca, 0x5c, 0xc0, 0x59,
	0xc8, 0x61, 0xb9, 0xf9, 0x0e, 0xaf, 0xe4, 0x09, 0x0a, 0x10, 0xbc, 0x9a, 0x6b, 0x03, 0xe1, 0x2c,
	0x20, 0xea, 0x5a, 0xae, 0xda, 0x04, 0xa6, 0xd2, 0xa8, 0xef, 0xe2, 0xcb, 0x79, 0xc6, 0x16, 0x20,
	0x8c, 0xb7, 0x7e, 0x3d, 0x8b, 0x96, 0x77, 0xfd, 0xf0, 0x54, 0xfd, 0xd7, 0xd9, 0x4f, 0xd1, 0xe2,
	0x7b, 0xdb, 0xf7, 0x5c, 0x5e, 0xfc, 0x11, 0x75, 0x8c, 0xb1, 0x5a, 0xe2, 0x86, 0xa6, 0x08, 0xc3,
	0x8a, 0x8a, 0x7e, 0x49, 0xfb, 0x05, 0x9a, 0x57, 0x55, 0xa3, 0xbc, 0x81, 0xa5, 0xf1, 0x81, 0x82,
	0xa2, 0x5f, 0xd2, 0xbe, 0x44, 0x0b, 0x3b, 0x34, 0x61, 0x71, 0x78, 0x3e, 0x61, 0xbc, 0x28, 0xe6,
	0xe5, 0x4c, 0xfc, 0x33, 0x34, 0x27, 0x4a, 0x49, 0xb9, 0xe3, 0x6e, 0x8e, 0x8f, 0xe3, 0x23, 0xf4,
	0x4b, 0xda, 0x4f, 0x50, 0x91, 0xd7, 0x70, 0xae, 0x8e, 0x8c, 0x95, 0xe3, 0x6e, 0x8c, 0x8f, 0x03,
	0xb0, 0x7e, 0x49, 0xdb, 0x42, 0x73, 0xbb, 0x7e, 0x2f, 0xe9, 0x4c, 0x1e, 0x37, 0x59, 0xce, 0x9f,
	0xa0, 0x05, 0x55, 0x6a, 0xbc, 0x36, 0x32, 0x4a, 0xf6, 0xe6, 0xea, 0x75, 0x69, 0x50, 0x51, 0xd4,
	0x6e, 0x8c, 0x0c, 0x1c, 0xf4, 0x67, 0x25, 0x55, 0xa5, 0x29, 0xfd, 0xd2, 0xa7, 0x79, 0x5e, 0x8a,
	0x7e, 0xfb, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc8, 0xc0, 0xd0, 0x5a, 0x29, 0x3c, 0x00, 0x00,
}
